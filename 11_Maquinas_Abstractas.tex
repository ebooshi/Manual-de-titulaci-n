%    Octavo Capítulo: Máquinas Abstractas.
%    Ejercicios por Barón L. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 5/6/23
%    Concluido el 19/6/23

%Gatito lambda
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=0.6]{assets/08_gatito_abstracto.jpg}}
\end{figure}

\bigskip

Una máquina abstracta define una colección de estados y reglas de transición que nos permiten obtener información acerca de la ejecución de un programa por cada cómputo que este realiza.
Este tipo de mecanismos de evaluación ya han sido revisados en cursos previos, específicamente en autómatas y lenguajes formales\footnote{Conforme al plan de estudios que se imparte desde el 2013 en la Facultad de Ciencias de la Universidad Nacional Autónoma de México con clave de asignatura 1425. }, donde se estudian sistemas de transición como autómatas y las máquinas de Turing. \\\\
En este capítulo introduciremos un sistema de cómputo mezclando las ideas de los sistemas de transición para definir una máquina de ejecución para \textsf{MinHS}, conocidas como las máquinas $\Hs$ y $\Js$.

\subsubsection{Objetivo}
En este capítulo exploraremos la definición de las máquinas $\Hs$ y $\Js$ implementando la colección de estados, cómputos y los axiomas de transición que nos permitan visualizar el proceso de evaluación de un expresión cerrada de \textsf{MinHS}, ejemplos de programas válidos serán revisados para ilustrar los cómputos. 

\subsubsection{Planteamiento}

El capítulo está estructurado para definir los estados, marcos y reglas de transición de las máquinas $\Hs$ y $\Js$ seguido de la ejecución detallada paso a paso de programas correctamente formados de \textsf{MinHS} para ilustrar la ejecución de ambas máquinas. \\\\
De forma similar, la pila de ejecución será introducida para controlar aquellos cómputos que se quedan pendientes de evaluación, hasta obtener un valor que pueda ser regresado como argumento a la última llamada contenida en el tope de la misma.  Progresando así en la ejecución del programa. \\\\
Posteriormente extenderemos la definición de la máquina $\Hs$  para abstraer el manejo de variables definiendo así la máquina $\Js$.\\\\
Finalmente se estudian los conceptos de alcance estático y dinámico que cada una de estas implementa junto con el concepto de cerradura.

\section{La máquina $\Hs$}
 Para la implementación de este máquina de estados es necesaria la introducción de marcos. Los marcos representan un programa con marcadores de los cómputos pendientes que necesitamos para continuar con la evaluación de un determinado estado en la expresión de \textsf{MinHS} que queremos evaluar. Adicionalmente se presenta la pila de ejecución para llevar un control de dichos cómputos (en inglés se conocen como $frames$ pero en esta nota les llamaremos "marcos"\footnote{Este término es una traducción directa de \hyperlink{return}{[122]}}).\\\\
Esta implementación resulta particularmente cómoda para seguir la ejecución de un programa de una manera simple y legible. Sin embargo, posteriores optimizaciones serán propuestas con la introducción de la máquina $\Js$

\bigskip

 \subsection{Marcos y la pila de control}
  Los marcos (o $frames$ en inglés) son estructuras sintácticas que denotan cómputos pendientes en la evaluación de un programa. Por ejemplo, para el caso de los operadores, si ambos operandos no han sido evaluados exhaustivamente hasta ser reducidos a un valor, la ejecución del operador no puede continuar.
 Es aquí cuando los marcos resultan útiles para indicar que no se continuará con la evaluación del programa hasta no resolver los cómputos pendientes en dicho marco.\\\\
Adicionalmente tendremos una pila en la que almacenaremos todos los marcos pendientes para conservar el orden en el que se fueron encontrando en el programa.  Cada marco será empujado al tope de la pila para evaluar las subexpresiones asociados a el. \\\\
Una vez concluida la evaluación de las subexpresiones de éste computo, el valor obtenido es empujado al siguiente marco en el tope de la pila y detenido hasta que todas las subexpresiones hayan sido terminadas de evaluar, ó se regresa como valor final si la pila está vacía (según sea el caso aplicable por axioma). \\\\
 \begin{definition}[Marcos] Los marcos son marcadores estructurales que registran los cómputos pendientes de una expresión. En nuestra definición, el símbolo $\square$ indica el lugar en donde se está llevando acabo la evaluación actual\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]}, \hyperlink{12}{[12]}, y \hyperlink{122}{[122]} }. \\
    \begin{description}
        \item[Operadores primitivos]
            \[
                \begin{array}{ccc}
                    \inference{}
                    {O(\square,e_2)\ marco }& 
                    \qquad&
                    \inference{}
                    {O(v_1,\square)\ marco}
                \end{array}
            \]
        \item[Condicional] 
            \[
                \begin{array}{c}
                    \inference{}
                    {if(\square,e_2,e_3)\ marco}
                \end{array}
            \]
        \item[Aplicación de función] 
            \[
                    \inference{}
                    {app(\square, e_2)\ marco}
            \]
        %\item[Asignaciones locales] 
         %   \[
          %          \inference{}
           %         {let(\square, x.e_1)\ marco}
           % \]  


	Notemos que los operadores \textsf{fix}, \textsf{fun} y \textsf{recfun} no tienen una definición con un marco. Esto es porque estas expresiones solo pueden ser aplicadas con la expresión \textsf{app} que define el marcador de cómputo pendiente para el argumento de la función.
    \end{description}
\end{definition}


\begin{definition}[Pila de control] Una pila de control está formada a partir de marcos, y se define recursivamente como sigue\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} \hyperlink{12}{[12]}, y \hyperlink{122}{[122]} }:

    \[
        \begin{array}{ccc}
            \inference{}{\diamond \ pila}[{vacia}]&
            \qquad&
            \inference{$m$ \ marco& $p$ \ pila}{$m$;$p$\ pila}[{top}]
        \end{array}
    \]

\bigskip
\end{definition}
\subsection{Estados}
Los estados para la máquina $\Hs$ estarán agrupados en dos categorías; de evaluación y de retorno. Los estados de evaluación exhaustan una expresión hasta obtener un valor y los de retorno empujarán dicho valor a la pila de control (los valores pueden ser retornados a un marco o regresados como valores finales).\\\\
Los estados iniciales comenzarán la evaluación de una expresión con una pila vacía y los estados finales retornarán un valor a una pila vacía.
\begin{definition}[Estados de la máquina $\Hs$] Los estados están compuestos de una pila de control $P$ y una expresión $e$ cerrada y son de alguna de las siguientes formas\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]} }:
\bigskip
\begin{itemize}
    \item {\bf Estados de evaluación}: Se evalúa $e$ siendo $P$ la pila de control y lo denotamos como $P\succ e$
    \item {\bf Estados de retorno}: Devuelve el valor $v$ a la pila de control $P$, que denotamos como $P\prec v$
\end{itemize}
\bigskip
En donde se distinguen dos tipos de estados en particular:
\bigskip
\begin{itemize}
    \item {\bf Estados iniciales}: comienzan la evaluación con la pila vacía denotados como \\$\diamond\succ e$.
    \item {\bf Estados finales}: regresan un valor a la pila vacía y se denota\\ $\diamond\prec v$
\end{itemize}
\bigskip
\end{definition}

\subsection{Transiciones}

La función de transición vincula la pila de ejecución con los marcos, definiendo las transiciones posibles entre cada uno de los estados.\\\\
Sí el cómputo pendiente de un marco ha terminado su evaluación, el valor regresa al marcador de lugar y se continúa con el resto de los cómputos. Sí todos los cómputos han sido resueltos entonces se evalúa lo operación con los valores retornados al marco.

\begin{definition}[Transiciones para la máquina $\Hs$]
Las transiciones se definen por medio de la relación $\rightarrow_{\Hs}$ y son de la forma\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}} :

$$P \succ e\rightarrow_{\Hs} P' \succ e'$$

\bigskip
\begin{description}
    \item[Valores] Los valores del lenguaje son números, booleanos y funciones. La evaluación de un valor simplemente lo regresa como resultado a la pila, pues un valor ya finalizó su proceso de evaluación.
    \[
        \inference{}{P \succ v\rightarrow_{\Hs} P \prec v}
    \]
\medskip
    \item[Operaciones] Definimos el proceso para evaluar cualquier operador de la siguiente forma: Para evaluar $O(e_1,e_2)$ agregamos el marco $O(\square,e_2)$ a la pila y evaluamos $e_1$.
    \[
        \inference{}{P\succ O(e_1,e_2)\rightarrow_{\Hs}O(\square,e_2);P\succ e_1}
    \]

    Si tenemos en el tope de la pila el marco $O(\square,e_2)$ y se regresa como resultado un valor $v$, entonces, evaluamos $e_2$ y sustituimos el tope de la pila por el marco $O(v_1,\square)$.
    \[
        \inference{}{O(\square,e_2);P\prec v_1\rightarrow_{\Hs}O(v_1,\square);P\succ e_2}
    \]
\medskip
    Si se devuelve un valor a la pila que tiene como tope el marco $O(v_1,\square)$ entonces podemos devolver al resto de la pila el resultado de la operación de ambos valores. 
    Aplicando este principio a la operación \textsf{sum} tenemos la siguiente regla.
    \[
        \inference{}{sum(num[n],\square);P \prec num[m] \rightarrow_{\Hs} P \prec num[n + m]}
    \]
\medskip
    \item[Condicional] Para evaluar la expresión $if(e_1,e_2,e_3)$ agregamos el marco $if(\square,e_2,e_3)$ al tope de la pila y evaluamos $e_1$.
    \[
        \inference{}{P \succ if(e_1,e_2,e_3)\rightarrow_{\Hs}if(\square,e_2,e_3);P \succ e_1}
    \]
    Si se regresa \textsf{True} a la pila con el marco $if(\square,e_2,e_3)$ en el tope, entonces evaluamos $e_2$ con el resto de la pila.
    \[
        \inference{}{if(\square,e_2,e_3);P \prec\textsf{True} \rightarrow_{\Hs}P\succ e_2}
    \]
    Si se regresa \textsf{False} a la pila con el marco $if(\square,e_2,e_3)$ en el tope, entonces evaluamos $e_3$ con el resto de la pila.
    \[
        \inference{}{if(\square,e_2,e_3);P\prec\textsf{False}\rightarrow_{\Hs}P\succ e_3}
    \]
    \item[Asignaciones locales] Si se quiere evaluar la expresión $let(e_1,x.e_2)$ con la pila $P$ entonces se evalúa $e_2$ en donde se sustituyen las apariciones de $x$ por $e_1$.
   % \[
     %   \inference{}{P\succ let(e_1,x.e_2)\rightarrow_{\Hs}let(\square,x.e_2);P \succ e_1}
    %\]
%\medskip
    \[
        \inference{}{P \succ  let(e_1, x.e_2) \rightarrow_{\Hs} P \succ  e_2[x := e_1]}
    \]
    % Si se quiere evaluar la expresión $\letrec(f.e_1,f.e_2)$ con la pila $P$ entonces se evalúa $e_2$ en donde se sustituyen las apariciones de $f$ por $\fix(f.e_1)$ con la misma pila.
    % \[
    %     \inference{}{P\succ\letrec(f.e_1,f.e_2)\rightarrow_{\Hs}P\succ e_2[f:=\fix(f.e_1)]}
    % \]
    \item[Aplicación de función] Para evaluar una aplicación $app(e_1,e_2)$ en una pila $P$ se agrega el marco $app(\square,e_2)$ como tope y se evalúa $e_1$.
    Si se regresa un valor $ fun(x.e_1)$ a la pila con tope $app(\square,e_2)$ entonces se quita el tope  y se evalúa $e_1$ sustituyendo $x$ por $e_2$.
    \[
        \inference{}{P \succ app(e_1 ,e_2) \rightarrow_{\Hs} P; app(\square, e_2) \succ e_1}
    \]
\medskip
    \[
        \inference{}{app(\square,e_2);P\prec fun(x.e_1)\rightarrow_{\Hs}  P \succ e1[x := e_2]}
    \]
%\medskip
  %  \[
   %     \inference{}{app(fun(x.e_1),\square);P\prec v_1 \rightarrow_{\Hs}P\succ e_1 [x:=v_1]}
   % \]
$$$$
    Si se regresa un valor $ recfun(f.x.e_1)$ a la pila con tope $app(\square,e_2)$ entonces se quita el tope  y se evalúa $e_1$ sustituyendo $f$ por su punto fijo y $x$ por $e_2$.
    \[
        \inference{}{app(\square,e_2);P\prec recfun(f.x.e_1)\rightarrow_{\Hs}   P \succ e_1[f:= fix(f.x.e_1),x:=e_2]}
    \]
%\medskip
  %  \[
    %    \inference{}{app(recfun(f.x.e_1), \square):P \prec v_1 \rightarrow_{\Hs} P\succ [f:= fix(f.x.e_1),x:=v_1]}
    %\]
$$$$
    % Si en el tope de la pila tenemos el marco $app( fun(x.e),\square)$ y re regresa el valor $v$ entonces evaluamos $e$ sustituyendo las apariciones de $x$ por $v$ en el resto de la pila.
    % \[
    %     \inference{}{app( fun(x.e_1),\square);P\prec v\rightarrow_{\Hs}P\succ e[x:=v]}
    % \]
    \item[El operador de punto fijo] Para evaluar la expresión $ fix(f.e)$ en la pila $P$ se evalúa $e$ sustituyendo $f$ por $ fix(f.e)$.
    \[
        \inference{}{P\succ fix(f.e)\rightarrow_{\Hs}P\succ e[f:= fix(f.e)]}
    \]
\end{description}
\end{definition}

\begin{exercise}[Ejecución máquina $\Hs$ con {\it marcos}] Para ver el funcionamiento de la máquina $\Hs$ vamos a evaluar la siguiente expresión:

\begin{lstlisting}
    let x = False in
        let y = 4 in
           if x then y + 1 else y - 1 
        end
    end
\end{lstlisting}
En sintaxis abstracta:
$$let(\textsf{False},x.let(4,y.if(x,sum(y,1),sub(y,1)))))$$
La evaluamos en la máquina $\Hs$.

\[
 \scalemath{0.85}{
    \begin{array}{rccl}
        \diamond & \succ & let(\textsf{False},x.let(4,y.if(x,sum(y,1),sub(y,1)))) & \rightarrow_{\Hs} \\
	%  let(\square,x.let(4,y.if(x,sum(y,1),sub(y,1)))):\diamond & \succ & \textsf{False} & \rightarrow_{\Hs} \\
	 % let(\square,x.let(4,y.if(x,sum(y,1),sub(y,1)))):\diamond & \prec & \textsf{False} & \rightarrow_{\Hs} \\
        \diamond & \succ & let(4,y.if(x,sum(y,1),sub(y,1)))[x:=\textsf{False}] & \rightarrow_{\Hs} \\
        \diamond & \succ & let(4,y.if(\textsf{False},sum(y,1),sub(y,1))) & \rightarrow_{\Hs} \\
	 % let(\square,y.if(\textsf{False},sum(y,1),sub(y,1))):\diamond & \succ & 4  & \rightarrow_{\Hs} \\
	  %let(\square,y.if(\textsf{False},sum(y,1),sub(y,1))):\diamond & \prec & 4  & \rightarrow_{\Hs} \\
        \diamond & \succ & if(\textsf{False},sum(y,1),sub(y,1))[y := 4] & \rightarrow_{\Hs} \\
        \diamond & \succ & if(\textsf{False},sum(4,1),sub(4,1)) & \rightarrow_{\Hs} \\
        if(\square,sum(4,1),sub(4,1)):\diamond & \succ &\textsf{False} & \rightarrow_{\Hs} \\
        if(\square,sum(4,1),sub(4,1)):\diamond & \prec &\textsf{False} & \rightarrow_{\Hs} \\
        \diamond & \succ & sub(4,1) & \rightarrow_{\Hs} \\
        sub(\square,1):\diamond & \succ & 4 & \rightarrow_{\Hs} \\
        sub(\square,1):\diamond & \prec & 4 & \rightarrow_{\Hs} \\
        sub(4,\square):\diamond & \succ & 1 & \rightarrow_{\Hs} \\
        sub(4,\square):\diamond & \prec & 1 & \rightarrow_{\Hs}\\
        \diamond & \succ & 4 - 1 & \rightarrow_{\Hs} \\
        \diamond & \prec & 3 \\
    \end{array}
}
\]

\end{exercise}

\begin{exercise}[Ejecución máquina $\Hs$ con {\it marcos}] Para ver el funcionamiento de la máquina $\Hs$ vamos a evaluar la siguiente expresión:

\begin{lstlisting}
    let x = fun z -> z + 1 in
        let y = 4 in
           x y
        end
    end
\end{lstlisting}
En sintaxis abstracta:
$$let(fun(z.sum(z,1)),x.let(4,y.app(x,y)))$$
La evaluamos en la máquina $\Hs$.

\[
 \scalemath{0.95}{
    \begin{array}{rccl}
         \diamond & \succ & let(fun(z.sum(z,1)),x.let(4,y.app(x,y))) & \rightarrow_{\Hs} \\
	%   let(\square,x.let(4,y.app(x,y))):\diamond & \prec & fun(z.sum(z,1)) & \rightarrow_{\Hs} \\
         \diamond & \succ & let(4,y.app(x,y))[ x := fun(z.sum(z,1))] & \rightarrow_{\Hs} \\
         \diamond & \succ & let(4,y.app(fun(z.sum(z,1)),y)) & \rightarrow_{\Hs} \\
	%  let(\square,y.app(fun(z.sum(z,1)),y)):\diamond & \succ & 4 &  \rightarrow_{\Hs}\\
	 % let(\square,y.app(fun(z.sum(z,1)),y)):\diamond & \prec & 4 &  \rightarrow_{\Hs}\\
         \diamond & \succ & app(fun(z.sum(z,1)),y)[y := 4] & \rightarrow_{\Hs} \\
         \diamond & \succ & app(fun(z.sum(z,1)),4) & \rightarrow_{\Hs} \\
    %\end{array}
    %\begin{array}{rccl}
         app(\square, 4)\ : \diamond & \succ & fun(z.sum(z,1)) & \rightarrow_{\Hs} \\
         app(\square, 4)\ : \diamond & \prec & fun(z.sum(z,1)) & \rightarrow_{\Hs} \\
 	 % app(fun(z.sum(z,1)),\square)\ : \diamond & \succ & 4 & \rightarrow_{\Hs} \\
 	  % app(fun(z.sum(z,1)),\square)\ : \diamond & \prec & 4 & \rightarrow_{\Hs} \\
         \diamond & \succ & sum(z,1)[z := 4] & \rightarrow_{\Hs} \\
         \diamond & \succ & sum(4,1) & \rightarrow_{\Hs} \\
         sum(\square,1) : \diamond & \succ & 4 & \rightarrow_{\Hs} \\
         sum(\square,1) : \diamond & \prec & 4 & \rightarrow_{\Hs} \\
         sum(4,\square) : \diamond & \succ & 1 & \rightarrow_{\Hs} \\
         sum(4,\square) : \diamond & \prec & 1 & \rightarrow_{\Hs} \\
         \diamond & \succ & 4 + 1 & \rightarrow_{\Hs} \\
         \diamond & \prec & 5  \\

    \end{array}
}
\]
\end{exercise}

\bigskip

\section{La máquina $\Js$}

La máquina $\Js$ es una extensión de la máquina $\Hs$ con la adición de un $cache$ para almacenar variables y sus valores al que denominamos entorno. Este entorno será el encargado de regresar el valor asociado a un atributo en las operaciones de sustitución (\textsf{let}, \textsf{fix}, \textsf{fun}, \textsf{app}).
Esto con el objetivo de tener una implementación eficiente para la sustitución, operación que hasta el momento posee una complejidad lineal sobre el tamaño de la expresión que queremos evaluar.\\\\
Con pequeños ajustes podemos redefinir este nuevo modelo partiendo de las reglas definidas para $\Hs$ los cuales discutiremos a continuación.

\bigskip


\subsection{Marcos}

\begin{definition}[Marcos] En la máquina $\Js$ se usa el mismo conjunto de marcos que los presentados para la máquina $\Hs$, con la única excepción siendo los marcos de \textsf{let} y \textsf{app} para implementar una evaluación ansiosa con el fin de simplificar las operaciones de sustitución.\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}.\\

\textbf{Asignaciones locales}
$$\inference{}{let(\square, x.e_2) \ marco}$$

\textbf{Aplicación de función}
$$\inference{}{app(f, \square)\ marco}$$
\end{definition}



\subsection{Ambientes}
La introducción del concepto de ambientes, nos permitirá almacenar los pares $variable$ / $valor$ en un contexto para optimizar la resolución de una asignación en las expresiónes evluadas por $\Js$.
Los ambientes se definen de forma análoga a las listas como veremos en la siguiente especificación.

\begin{definition}[Ambientes] Un ambiente es una estructura que almacena asignaciones de variables con su valor y la definimos recursivamente como\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:
    \[
        \begin{array}{ccc}
            \inference{}{\bullet \ env}[{\ vacio}]&
            \qquad&
            \inference{x\;\;{\ var}&v\;\;{\ valor}& \E \ env}{x\leftarrow v\ ; \E \ env}[{\ asig}]
        \end{array}
    \]
    La forma de acceder a los elementos del ambiente es mediante el nombre de la variable, entonces si el ambiente $\E$ tiene la asignación $x\leftarrow v$. Podemos acceder al valor de $x$ como $\E[x]$ y el resultado es $v$. \\

    En caso de tener mas de una asignación sobre el mismo nombre de variable $\E [x]$ nos regresa la primera aparición de $x$ en el ambiente. Por ejemplo en el ambiente $\E  =_{def} x\leftarrow v_1;x\leftarrow v_2;\bullet$ la operación $\E [x]$ nos arroja como resultado $v_1$.
\bigskip
\end{definition}


\subsection{Estados}

\begin{definition}[Estados de la máquina $\Js$]
Los estados ahora son una relación ternaria de una pila de control $P$ un ambiente $\E $ y una expresión $e$, denotados como\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:\\
\begin{itemize}
    \item { \textbf{Estados de evaluación}: }$P\ |\ \E \succ e$
    \item { \textbf{Estados de retorno}: }$\ \ \ \ P\ |\ \E \prec e$\\
\end{itemize}

Un estado inicial es de la forma:
$$\diamond\ |\ \bullet \succ e$$\\
Mientras que los estados finales son de la forma:
$$\diamond\ |\ \E \prec v$$
Notemos que en los estados finales no importa que está guardado en el ambiente solo importa que la pila de control esté vacía.
\bigskip
\end{definition}

\subsection{Transiciones}

\begin{definition}[Transiciones de variables en la máquina $\Js$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}] A continuación brindamos la especificación para la regla de transición buscando el valor asociado a una variable desde el contexto.\\
\begin{description}
    \item[Variables] En la máquina $\Hs$ una variable representa un estado bloqueado, pues no hay forma de continuar la evaluación del programa si no se aplica una operación de sustitución sobre la misma.\\\\
                            En la máquina $\Js$ no está definida la operación de sustitución. Tenemos que evaluar las variables buscándolas en el ambiente, lo que definimos con la siguiente regla:
    \[
        \inference{}{P\ |\ \E \succ x \to_{j} P\ |\ \E \prec\E [x]}
    \]
\end{description}
\end{definition}

        \bigskip

Queremos utilizar los ambientes para introducir el concepto de alcance de una variable\footnote{Exploraremos de manera formal este concepto mas adelante en este capítulo.}. De manera informal el alcance de una variable es la porción del programa donde la definición de dicha variable es válida, por ejemplo en la expresión:

$$let(e_1,x.e_2 )$$

El alcance de $x$ solo estará definido para el cuerpo de la expresión $e_2$. Una vez que se termine de evaluar la expresión $let$ queremos eliminar del ambiente la asignación $x \leftarrow e_1$ para que no figure en el alcance de  futuras evaluaciones. Para esto debemos extender la pila de los marcos para que pueda almacenar ambientes y deshacerse de ellos.

        \bigskip

\begin{definition}[Pila de control para $\Js$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}]

    \[
        \begin{array}{ccccc}
            \inference{}{\diamond \ pila}[{\sf vacia}]&
            \quad&
            \inference{m\ marco&P\ pila}{m;P\ pila}[{\sf top}]&
            \quad&
            \inference{\E \ env&P\ pila}{\E\ ; P\ pila}[{\sf top}]
        \end{array}
    \]
\bigskip

De esta forma cuando evaluemos una expresión que genera un ambiente distinto (llamémosle ambiente B), se guarda el ambiente actual en la pila de control (llamémosle ambiente A) y se definen las nuevas asignaciones dentro del ambiente B.\\\\
Una vez que termine la ejecución y se regrese un valor a la pila, recuperamos el ambiente A y continuamos con la ejecución del programa.
\end{definition}

Finalmente enlistaremos las transiciones para la máquina $\Js$ que difieren con la máquina $\Hs$. El resto de transiciones que no aparecen en esta definición se heredan directamente de esta última máquina. \\\\
Estas reglas permiten manipular los entornos para guardar, definir y sustituir variables durante la ejecución del programa. Una vez concluida los entornos serán descartados hasta liberar la pila de ejecución para retornar el valor final.

\begin{definition}[Transiciones con alcance en la máquina $\Js$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}] A continuación brindamos la especificación de las reglas de evaluación que involucran la aplicación de la sustitución para resolverse.\\
\begin{description}
    \item[Asignaciones locales]
    \[  
        \begin{array}{c}
            \inference{}{P\ |\ \E \succ let(e_1,x.e_2) \to_{\Js} let(\square,x.e_2);P\ |\ \E \succ e_1}\\
            \\
            \inference{}{let(\square,x.e_2)\ ;\ P\ |\ \E \prec v\to_{\Js} \E \ ;\ P\ |\ x\leftarrow v\ ;\ \E \succ e_2}
        \end{array}
    \]
\bigskip
    \item[Aplicación de función] 
    \[
    \begin{array}{c}
        \inference{}{app(\square,e_2);P\ |\ \E \prec v_1\to_{\Js} app(v_1,\square);P\ |\ \E \succ e_2}\\
        \\
        \inference{}{app(fun(x.e_1),\square)\ ;\ P\ |\ \E \prec v_2 \to_{\Js} \E\ ;\ P\ |\ x\leftarrow v_2; \E \succ e_1}\\
        \\
        \inference{}{app(recfun(f.x.e_1),\square);P | E \prec v_2\to_{\Js} \E ;P | f\leftarrow fix(f.x.e_1) ; x\leftarrow v_2; \E \succ e_1}\\
    \end{array}
    \]
\bigskip
    \item[Liberación del ambiente] 
    \[
        \inference{}{\E ;P\ |\ \E_1\prec v\to_{\Js}P\ |\ \E \prec v}
    \]

\bigskip

   Esta regla se agrega para liberar el ambiente de la pila de control.

\end{description}
\end{definition}

\begin{exercise}{Ejecución de la máquina $\Js$}
Tomemos como ejemplo la siguiente expresión de \textsf{MinHS}
\bigskip
    \begin{lstlisting}
            let f = fun x => x + y + z in
                let y = 4 in
                    let z = 10 in
                        f 1
                    end    
                end
            end    
    \end{lstlisting}
\bigskip

    La cual nos da la siguiente representación en sintaxis abstracta:

\bigskip
    $$ let(fun(x.sum(x,sum(y,z)),f.let(4,y.let(10,z.app(f,1)))) $$

\bigskip
    La evaluación en la máquina $\Js$ es de la siguiente forma:

    \[
\begin{turn}{270}
    \scalemath{0.9}{
        \begin{array}{rccl}
            \diamond\ |\ \bullet & \succ & let(fun(x ... )) & \rightarrow_{\Js}\\
            let(\square, f.let( ...)) : \diamond\ |\ \bullet & \succ & fun(x.sum(x,sum(y,z))) & \rightarrow_{\Js} \\
            let(\square, f.let( ...)) : \diamond\ |\ \bullet & \prec & fun(x.sum(x,sum(y,z))) & \rightarrow_{\Js} \\
            \bullet : \diamond\ |\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & let(4,y.let(10,z.app(f,1))) & \rightarrow_{\Js} \\
            let(\square,y.let(10,z.app(f,1))) :  \bullet : \diamond\ |\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 4 & \rightarrow_{\Js} \\
            let(\square,y.let(10,z.app(f,1))) :  \bullet : \diamond\ |\ \underline{f \leftarrow fun(x.sum(x,sum(y,z))) :\ \bullet}_{E_1} & \prec & 4 & \rightarrow_{\Js} \\
            E_1\ :  \bullet : \diamond\ |\ y \leftarrow 4\ :\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & let(10,z.app(f,1)) & \rightarrow_{\Js} \\
            let(\square, z,app(f,1)) : E_1 :  \bullet : \diamond\ |\ y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 10 & \rightarrow_{\Js} \\
            let(\square, z,app(f,1)) : E_1 :  \bullet : \diamond\ |\  \underline{y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet}_{E_2} & \prec & 10 & \rightarrow_{\Js} \\
            E_2 : E_1 :  \bullet : \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & app(f,1) & \rightarrow_{\Js} \\
            app(\square,1) : E_2 : E_1 :  \bullet :  \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & f & \rightarrow_{\Js} \\
            app(\square,1) : E_2 : E_1 :  \bullet :  \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & fun(x.sum(x,sum(y,z))) & \rightarrow_{\Js} \\
            app(\square,1) : E_2 : E_1 :  \bullet : \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & fun(x.sum(x,sum(y,z))) & \rightarrow_{\Js} \\
            app(fun(x.sum(x,sum(y,z))),\square) : E_2 : E_1 :  \bullet : \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 1& \rightarrow_{\Js} \\
            app(fun(x.sum(x,sum(y,z))),\square) : E_2 : E_1 :  \bullet : \diamond\ |\ \underline{z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet}_{E_3} & \prec & 1 & \rightarrow_{\Js}\\
            E_3 : E_2 : E_1 :  \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & sum(x,sum(y,z)) & \rightarrow_{\Js} \\
            sum(\square,sum(y,z)) : E_3 : E_2 : E_1 :  \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & x & \rightarrow_{\Js} \\
            sum(\square,sum(y,z)) : E_3 : E_2 : E_1 :  \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 1 & \rightarrow_{\Js} \\

            sum(1,\square) : E_3 : E_2 : E_1 :  \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & sum(y,z) & \rightarrow_{\Js} \\
            sum (\square, z): sum(1,\square) : E_3 : E_2 : E_1 :  \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & y & \rightarrow_{\Js} \\
            sum (\square, z): sum(1,\square) : E_3 : E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 4 & \rightarrow_{\Js} \\

            sum (4, \square): sum(1,\square) : E_3 : E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & z & \rightarrow_{\Js} \\
            sum (4, \square): sum(1,\square) : E_3 : E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 10 & \rightarrow_{\Js} \\
            sum(1,\square) : E_3 : E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 4 + 10 & \rightarrow_{\Js} \\
            E_3 : E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 14 + 1 & \rightarrow_{\Js} \\
            E_2 : E_1 : \bullet : \diamond\ |\ E_3 : \bullet & \prec & 15 & \rightarrow_{\Js} \\
            E_1 : \bullet : \diamond\ |\ E_2 : \bullet & \prec & 15 & \rightarrow_{\Js} \\
	 \bullet : \diamond\ |\ E_1 : \bullet & \prec & 15 & \rightarrow_{\Js} \\
            \diamond\ |\ \bullet & \prec & 15 & \rightarrow_{\Js} \\
        \end{array}
    }
\end{turn}
\]

\end{exercise}

\subsection{Alcance}
   El alcance de una variable es la porción del programa en la cual esta está definida. Dependiendo de la implementación del lenguaje este alcance puede ser estático o dinámico.\\

    \begin{definition}[Alcance estático] Para los programas que implementan alcance estático, las variables solo estarán definidas en un área delimitada por bloques de indentación, marcadores de lugar como el operador \textsf{let, in, end}, cuerpo de una función etc\footnote{Definición extraída de \hyperlink{2}{[2]} y \hyperlink{107}{[107]}}.
    \end{definition}
    
    \begin{definition}[Alcance dinámico] En un lenguaje que implementa el alcance dinámico, el alcance de una variable es todo el programa y se toma la última asignación hecha a la misma cuando se requiera evaluar\footnote{Definición extraída de  \hyperlink{2}{[2]} y \hyperlink{107}{[107]}}.
    \end{definition}


\subsection{Cerraduras}
    Los alcances de las máquinas $\Hs$ y $\Js$ suponen un problema dado que los resultados obtenidos al evaluar la misma expresión son distintos para las expresiones de tipo función.\\\\ Esto se debe de corregir para la definición de la máquina $\Js$ mediante la introducción de cerraduras, que encapsulan el contexto de evaluación y la expresión para la que dicho contexto será aplicado cuando se evalúe.\\\\
    Las cerraduras nos ayudan a imitar la definición de un alcance estático en la implementación de $\Js$, para esto deberemos modificar las reglas de evaluación.\\
    
    \begin{definition}[Cerraduras]
        Una  cerradura  es una pareja de una expresión de función de \textsf{MinHS} y un ambiente que se denota\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:
        
        $$\ll \E,f \gg$$
        
        Cuya interpretación es que el ambiente adecuado para evaluar la función $f$ es $\E$. \\\\De esta forma se respeta el ambiente en el que se define una función para usar el mismo en su ejecución y tener una evaluación con alcance estático.
        \bigskip
    \end{definition}
        
        \subsection{Transiciones con cerradura para $\Js$}
        
	Una vez hecho el análisis de la diferencia de alcances en ambas máquinas, necesitamos homogeneizar la evaluación para que el ambiente no introduzca efectos secundarios y el resultado de la evaluación de un programa en ambas máquinas difiera.\\\\

	\bigskip
          Solo las reglas que modifican el ambiente serán candidatas para ser ajustadas en la definición de las transiciones para la máquina $\Js$, en particular \textsf{app, fun, recfun y fix}.

        \begin{definition}[Transición para funciones] En lugar de regresar las funciones como una expresión, se guardará como una pareja de la expresión y el ambiente en el que fue definido\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}.
        
        \[
    \scalemath{0.8}{
            \begin{array}{c}
                \inference{}{P\ |\ \E \succ fun(x.e) \rightarrow_{\Js} P\ |\ \E \prec \ll \E,x.e \gg}\\
                \\
                \inference{}{app(\square,e_2); P\ |\ \E \prec \ll \E_f,x.e_1 \gg \rightarrow_{\Js} app(\ll \E_f,x.e_1\gg,\square); P\ |\ \E \succ e_2}\\
                \\
                \inference{}{app(\ll \E_f,x.e_1 \gg,\square); P\ |\ \E \prec v \rightarrow_{\Js} \E ; P\ |\ x\leftarrow v; \E_f \succ e_1}\\
                \\
                \inference{}{P\ |\ \E \succ recfun(f.x.e) \rightarrow_{\Js} P\ |\ \E \prec fix(f.\ll \E,x.e \gg)}\\
                \\
                \inference{}{app(\square,e_2); P | \E \prec fix(f.\ll \E_f,x.e_1\gg)\rightarrow_{\Js} app(fix(f.\ll \E_f,x.e_1\gg),\square); P\ |\ \E \succ e_2}\\
                \\
                \inference{}{app(fix(f.\ll \E_f,x.e_1\gg),\square); P\ |\ \E \prec v \rightarrow_{\Js} \E; P\ |\ x\leftarrow v;f\leftarrow fix(f.\ll \E_f,x.e_1 \gg );\E_f\succ e_1}
            \end{array}
}
        \]
    \end{definition}

\bigskip

	Para finalizar el capítulo presentamos un ejemplo de la evaluación en la máquina $\Js$ con las nuevas reglas para mostrar como ahora se pueden guardar ambientes y sustituirlos según se necesite durante el proceso de evaluación.\\\\
	Esto nos da la flexibilidad de capturar un ambiente para una porción específica del programa sin perder el resto de las asignaciones contenidas en el.\\\\
 	Una vez concluida la evaluación de la instrucción para la cual un ambiente fue guardado, se restaura el ambiente general para continuar con el resto del programa.

\bigskip

    \begin{exercise}
            \begin{lstlisting}
                let y = 4 in
                    let z = 10 in
                        let f = fun x => x + y + z in
                            f 1
                        end    
                    end
                end    
            \end{lstlisting}
    
        La cual nos da la siguiente representación en sintaxis abstracta:
    
        $$ let(4,y.let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1))))) $$
    
        La evaluación en la máquina $\Js$ es de la siguiente forma:
        \[
	\begin{turn}{270}
    	\scalemath{0.7}{
                \begin{array}{rccl}
                    \diamond\ |\ \bullet & \succ &  let(4,y.let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1)))) & \rightarrow_{\Js} \\
                    let(\square,y.let ... ) : \diamond\ |\ \bullet & \succ & 4 & \rightarrow_{\Js} \\
                    let(\square,y.let ... ) : \diamond\ |\ \bullet & \prec & 4 & \rightarrow_{\Js} \\
                    \bullet : \diamond\ |\ y \leftarrow 4 : \bullet & \succ & let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1))) & \rightarrow_{\Js} \\
                    let(\square,z.let ... ) : \bullet : \diamond\ |\ y \leftarrow 4 : \bullet & \succ & 10  & \rightarrow_{\Js} \\
                    let(\square,z.let ... ) : \bullet : \diamond\ |\ \underline{y \leftarrow 4 : \bullet}_{\ E_1} & \prec & 10 & \rightarrow_{\Js} \\
                    E_1 : \bullet : \diamond\ |\ z \leftarrow 10 : E_1 & \succ & let(fun(x.sum(x,sum(y,z)),f.app(f,1)) & \rightarrow_{\Js} \\
                    let(\square, f.app ...): E_1 : \bullet : \diamond\ |\ z \leftarrow 10 : E_1 & \succ & fun(x.sum(x,sum(y,z))) & \rightarrow_{\Js} \\
                    let(\square, f.app ...): E_1 : \bullet : \diamond\ |\ \underline{z \leftarrow 10 : E_1}_{\ E_2} & \prec &  \ll E_2, x.sum(x,sum(y,z)) \gg & \rightarrow_{\Js} \\
                    E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, x.sum(x,sum(y,z)) \gg  : E_2 & \succ & app(f,1) & \rightarrow_{\Js} \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, x.sum(x,sum(y,z)) \gg  : E_2 & \succ & f  & \rightarrow_{\Js} \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, x.sum(x,sum(y,z)) \gg  : E_2 & \succ &  \ll E_2, x.sum(x,sum(y,z)) \gg  & \rightarrow_{\Js} \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, x.sum(x,sum(y,z)) \gg  : E_2 & \prec &  \ll E_2, x.sum(x,sum(y,z)) \gg  & \rightarrow_{\Js}  \\
                    app(\ll E_2, x.sum(x,sum(y,z)) \gg, \square) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \succ &  1 & \rightarrow_{\Js}  \\
                    app(\ll E_2, x.sum(x,sum(y,z)) \gg, \square) :  E_2 : E_1 : \bullet : \diamond\ |\  \underline{f \leftarrow  \ll E_2, x.sum(x,sum(y,z)) \gg  : E_2}_{\ E_3} & \prec &  1   & \rightarrow_{\Js} \\
                    E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & sum(x,sum(y,z)) & \rightarrow_{\Js} \\
                    sum(\square, sum(y,z)) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & x & \rightarrow_{\Js} \\
                    sum(\square, sum(y,z)) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec & 1 & \rightarrow_{\Js} \\
                    sum(1, \square ) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1  : E_2 & \succ & sum(y,z) & \rightarrow_{\Js} \\
                    sum(\square, z) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & y & \rightarrow_{\Js}\\
                    sum(\square, z) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec & 4 & \rightarrow_{\Js} \\
                    sum(4, \square) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & z & \rightarrow_{\Js} \\
                    sum(4, \square) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec & 10 & \rightarrow_{\Js}\\
                    sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : E_2 & \prec & 10 + 4 & \rightarrow_{\Js} \\
                    E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ x \leftarrow 1 : E_2 & \prec & 14 + 1 & \rightarrow_{\Js}\\
                    E_2 : E_1 : \bullet : \diamond\ |\ E_3 & \prec & 15 & \rightarrow_{\Js} \\
                    E_1 : \bullet : \diamond\ |\  E_2 & \prec & 15 & \rightarrow_{\Js}\\
                    \bullet : \diamond\ |\ E_1 & \prec & 15 & \rightarrow_{\Js}\\
                    \diamond\ |\ \bullet & \prec & 15 &\\
                    
                \end{array}
            }
\end{turn}
        \]
         
            Como podemos observar el resultado obtenido ahora es el mismo en ambas máquinas, evaluando a 15.
    \end{exercise}

    \bigskip
    
    De esta forma concluimos el estudio de la implementación de las máquinas abstractas para \textsf{MinHS}. A continuación se encuentran los ejercicios de comprensión para el lector.


    \section{Ejercicios para el lector}

    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
           \bigskip 
	\begin{lstlisting}
                let x = False in
                    let y = fun z => leq(z,0) in
                        let x = True in
                            if x then y 0 else False
                        end
                    end
                end  
            \end{lstlisting}
\bigskip
             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}
\bigskip
    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
\bigskip
            \begin{lstlisting}
                let recfun pow x n = 
                    if  n = 0 then 1 else x * pow x  n-1 in
                        pow 2 4
                end        
            \end{lstlisting}
\bigskip
             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}
\bigskip
    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
\bigskip
            \begin{lstlisting}
                let recfun fib n = 
                    if n < 1 then 1 else n  +  fib n - 1 in
                        fib 5
                end        
            \end{lstlisting}
\bigskip
             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}
\bigskip

    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
\bigskip
            \begin{lstlisting}
                let recfun fac n = 
                    if n < 1 then 1 else n * fac n - 1 in
                        fac 4
                end        
            \end{lstlisting}
\bigskip
             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}
\bigskip
    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
\bigskip
            \begin{lstlisting}
                let x = True in
                    let x = False in
                        if x then 1 else 0
                    end
                end   
            \end{lstlisting}
\bigskip
             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}   


%http://www.dcc.ic.uff.br/~isabel/LP/D.Watt.pdf
%file:///C:/Users/luismun/Downloads/Modern-Programming-Languages-A-Practical-Introduction%20(1).pdf
%file:///C:/Users/luismun/3D%20Objects/Desktop/Titulacion/Benjamin_C._Pierce-Types_and_Programming_Languages-The_MIT_Press(2002).pdf 
%file:///C:/Users/luismun/3D%20Objects/Desktop/Titulacion/Practical%20Foundations%20for%20Programming.pdf