%    Octavo Capítulo: Máquinas Abstractas.
%    Ejercicios por Barón L. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 5/6/23
%    Concluido el 19/6/23

%Gatito lambda
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=0.6]{assets/11_gatito_abstracto.jpg}}
\end{figure}

\bigskip

Una máquina abstracta define una colección de estados y reglas de transición que nos permiten obtener información acerca de la ejecución de un programa por cada cómputo que este realiza.
Este tipo de mecanismos de evaluación ya han sido revisados en cursos previos, específicamente en autómatas y lenguajes formales\footnote{Conforme al plan de estudios que se imparte desde el 2013 en la Facultad de Ciencias de la Universidad Nacional Autónoma de México con clave de asignatura 1425. }, donde se estudian sistemas de transición como autómatas y las máquinas de Turing. \\\\
En este capítulo introduciremos un sistema de cómputo mezclando las ideas de los sistemas de transición para definir una máquina de ejecución para \textsf{MinHS}, conocidas como las máquinas $\Hs$ y $\Js$.

\subsubsection{Objetivo}
En este capítulo exploraremos la definición de las máquinas $\Hs$ y $\Js$ implementando la colección de estados, cómputos y los axiomas de transición que nos permitan visualizar el proceso de evaluación de un expresión cerrada de \textsf{MinHS}, ejemplos de programas válidos serán revisados para ilustrar los cómputos. 

\subsubsection{Planteamiento}

El capítulo está estructurado para definir los estados, marcos y reglas de transición de las máquinas $\Hs$ y $\Js$ seguido de la ejecución detallada paso a paso de programas correctamente formados de \textsf{MinHS} para ilustrar la ejecución de ambas máquinas. \\\\
De forma similar, la pila de ejecución será introducida para controlar aquellos cómputos que se quedan pendientes de evaluación, hasta obtener un valor que pueda ser regresado como argumento a la última llamada contenida en el tope de la misma, y progresar en la ejecución del programa. Posteriormente extenderemos la definición de la máquina $\Hs$  para abstraer el manejo de variables definiendo así la máquina $\Js$.\\\\
Finalmente se estudian los conceptos de alcance estático y dinámico que cada una de estas implementa junto con el concepto de cerradura.

\section{La máquina $\Hs$}
 Para la implementación de este máquina de estados es necesaria la introducción de marcos. Los marcos representan un programa con marcadores de los cómputos pendientes que necesitamos para continuar con la evaluación de un determinado estado en la expresión de \textsf{MinHS} que queremos evaluar. Adicionalmente se presenta la pila de ejecución para llevar un control de dichos cómputos (en inglés se conocen como $frames$ pero en esta nota les llamaremos "marcos"\footnote{Este término es una traducción directa de \hyperlink{126}{[126]}}).\\\\
Esta implementación resulta particularmente cómoda para seguir la ejecución de un programa de una manera simple y legible. Sin embargo, posteriores optimizaciones serán propuestas con la introducción de la máquina $\Js$

\bigskip

 \subsection{Marcos y la pila de control}
  Los marcos (o $frames$ en inglés) son estructuras sintácticas que denotan cómputos pendientes en la evaluación de un programa. Por ejemplo, para el caso de los operadores, si ambos operandos no han sido evaluados exhaustivamente hasta ser reducidos a un valor, la ejecución del operador no puede continuar.
 Es aquí cuando los marcos resultan útiles para indicar que no se continuará con la evaluación del programa hasta no resolver los cómputos pendientes en dicho marco.\\\\
Adicionalmente tendremos una pila en la que almacenaremos todos los marcos pendientes para conservar el orden en el que se fueron encontrando en el programa.  Cada marco será empujado al tope de la pila para evaluar las subexpresiones asociados a el. \\
Una vez concluida la evaluación de las subexpresiones de éste computo, el valor obtenido es empujado al siguiente marco en el tope de la pila y detenido hasta que todas las subexpresiones hayan sido terminadas de evaluar, ó se regresa como valor final si la pila está vacía (según sea el caso aplicable por axioma). \\\\
 \begin{definition}[Marcos] Los marcos son marcadores estructurales que registran los cómputos pendientes de una expresión. En nuestra definición, el símbolo $\square$ indica el lugar en donde se está llevando acabo la evaluación actual\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]}, \hyperlink{12}{[12]}, y \hyperlink{126}{[126]} }. \\
    \begin{description}
        \item[Operadores primitivos]
            \[
                \begin{array}{ccc}
                    \inference{}
                    {O(\square,e_2)\ marco }& 
                    \qquad&
                    \inference{}
                    {O(v_1,\square)\ marco}
                \end{array}
            \]
        \item[Condicional] 
            \[
                \begin{array}{c}
                    \inference{}
                    {if(\square,e_2,e_3)\ marco}
                \end{array}
            \]
        \item[Aplicación de función] 
            \[
                    \inference{}
                    {app(e_1,\square)\ marco}
            \]
        \item[Asignaciones locales] 
            \[
                    \inference{}
                    {let(\square, x.e_1)\ marco}
            \]  


	Notemos que los operadores \textsf{fix}, \textsf{fun} y \textsf{recfun} no tienen una definición con un marco. Esto es porque estas expresiones solo pueden ser aplicadas con la expresión \textsf{app} que define el marcador de cómputo pendiente para el argumento de la función.
    \end{description}
\end{definition}


\begin{definition}[Pila de control] Una pila de control está formada a partir de marcos, y se define recursivamente como sigue\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} \hyperlink{12}{[12]}, y \hyperlink{126}{[126]} }:

    \[
        \begin{array}{ccc}
            \inference{}{\diamond \ pila}[{vacia}]&
            \qquad&
            \inference{$m$ \ marco& $p$ \ pila}{$m$;$p$\ pila}[{top}]
        \end{array}
    \]

\bigskip
\end{definition}
\subsection{Estados}
Los estados para la máquina $\Hs$ estarán agrupados en dos categorías; de evaluación y de retorno. Los estados de evaluación exhaustarán una expresión hasta obtener un valor y los de retorno empujarán dicho valor a la pila de control (los valores pueden ser retornados a un marco o regresados como valores finales).\\\\
Los estados iniciales comenzarán la evaluación de una expresión con una pila vacía y los estados finales retornarán un valor a una pila vacía.
\begin{definition}[Estados de la máquina $\Hs$] Los estados están compuestos de una pila de control $P$ y una expresión $e$ cerrada y son de alguna de las siguientes formas\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]} }:
\bigskip
\begin{itemize}
    \item {\bf Estados de evaluación}: Se evalúa $e$ siendo $P$ la pila de control y lo denotamos como $P\succ e$
    \item {\bf Estados de retorno}: Devuelve el valor $v$ a la pila de control $P$, que denotamos como $P\prec v$
\end{itemize}
\bigskip
En donde se distinguen dos tipos de estados en particular:
\bigskip
\begin{itemize}
    \item {\bf Estados iniciales}: comienzan la evaluación con la pila vacía denotados como \\$\diamond\succ e$.
    \item {\bf Estados finales}: regresan un valor a la pila vacía y se denota\\ $\diamond\prec v$
\end{itemize}
\bigskip
\end{definition}

\subsection{Transiciones}

La función de transición vincula la pila de ejecución con los marcos, definiendo las transiciones posibles entre cada uno de los estados.\\\\
Sí el cómputo pendiente de un marco ha terminado su evaluación, el valor regresa al marcador de lugar y se continúa con el resto de los cómputos. Sí todos los cómputos han sido resueltos entonces se evalúa lo operación con los valores retornados al marco.

\begin{definition}[Transiciones para la máquina $\Hs$]
Las transiciones se definen por medio de la relación $\rightarrow_{h}$ y es de la forma\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}} :

$$P \succ e\rightarrow_{h} P' \succ e'$$

\bigskip
\begin{description}
    \item[Valores] Los valores del lenguaje son números, booleanos y funciones. La evaluación de un valor simplemente lo regresa como resultado a la pila, pues un valor ya finalizó su proceso de evaluación.
    \[
        \inference{}{P \succ v\rightarrow_{h} P \prec v}
    \]
\medskip
    \item[Operaciones] Definimos el proceso para evaluar cualquier operador de la siguiente forma: Para evaluar $O(e_1,e_2)$ agregamos el marco $O(\square,e_2)$ a la pila y evaluamos $e_1$.
    \[
        \inference{}{P\succ O(e_1,e_2)\rightarrow_{h}O(\square,e_2);P\succ e_1}
    \]

    Si tenemos en el tope de la pila el marco $O(\square,e_2)$ y se regresa como resultado un valor $v$, entonces, evaluamos $e_2$ y sustituimos el tope de la pila por el marco $O(v_1,\square)$.
    \[
        \inference{}{O(\square,e_2);P\prec v_1\rightarrow_{h}O(v_1,\square);P\succ e_2}
    \]
\medskip
    Si se devuelve un valor a la pila que tiene como tope el marco $O(v_1,\square)$ entonces podemos devolver al resto de la pila el resultado de la operación de ambos valores.
    \[
        \inference{}{O(v_1,\square);P \prec v_2 \rightarrow_{h} P \prec v_1\ O\ v_2}
    \]
\medskip
    \item[Condicional] Para evaluar la expresión $if(e_1,e_2,e_3)$ agregamos el marco $if(\square,e_2,e_3)$ al tope de la pila y evaluamos $e_1$.
    \[
        \inference{}{P \succ if(e_1,e_2,e_3)\rightarrow_{h}if(\square,e_2,e_3);P \succ e_1}
    \]
    Si se regresa \textsf{True} a la pila con el marco $if(\square,e_2,e_3)$ en el tope, entonces evaluamos $e_2$ con el resto de la pila.
    \[
        \inference{}{if(\square,e_2,e_3);P \prec\textsf{True} \rightarrow_{h}P\succ e_2}
    \]
    Si se regresa \textsf{False} a la pila con el marco $if(\square,e_2,e_3)$ en el tope, entonces evaluamos $e_3$ con el resto de la pila.
    \[
        \inference{}{if(\square,e_2,e_3);P\prec\textsf{False}\rightarrow_{h}P\succ e_3}
    \]
    \item[Asignaciones locales] Si se quiere evaluar la expresión $let(v,x.e)$ con la pila $P$ entonces se evalúa $e$ en donde se sustituyen las apariciones de $x$ por $v$.
    \[
        \inference{}{P\succ let(e_1,x.e_2)\rightarrow_{h}let(\square,x.e_2);P \succ e_1}
    \]
\medskip
    \[
        \inference{}{let(\square,x.e);P\prec v \rightarrow_{h}P \succ  e[x:=v]}
    \]
    % Si se quiere evaluar la expresión $\letrec(f.e_1,f.e_2)$ con la pila $P$ entonces se evalúa $e_2$ en donde se sustituyen las apariciones de $f$ por $\fix(f.e_1)$ con la misma pila.
    % \[
    %     \inference{}{P\succ\letrec(f.e_1,f.e_2)\rightarrow_{h}P\succ e_2[f:=\fix(f.e_1)]}
    % \]
    \item[Aplicación de función] Para evaluar una aplicación $app(e_1,e_2)$ en una pila $P$ se agrega el marco $app(\square,e_2)$ como tope y se evalúa $e_1$.
    Si se regresa un valor $ fun(x.e_1)$ a la pila con tope $app(\square,e_2)$ entonces se quita el tope  y se evalúa $e_1$ sustituyendo $x$ por $e_2$.
    \[
        \inference{}{app(\square,e_2);P\prec fun(x.e_1)\rightarrow_{h}app(fun(x.e_1),\square);P \succ e_2}
    \]
\medskip
    \[
        \inference{}{app(fun(x.e_1),\square):P\prec v_1 \rightarrow_{h}P\succ e_1 [x:=v_1]}
    \]
$$$$
    Si se regresa un valor $ recfun(f.x.e_1)$ a la pila con tope $app(\square,e_2)$ entonces se quita el tope  y se evalúa $e_1$ sustituyendo $f$ por su punto fijo y $x$ por $e_2$.
    \[
        \inference{}{app(\square,e_2);P\prec recfun(f.x.e_1)\rightarrow_{h}app(recfun(f.x.e_1), \square):P\succ e_2}
    \]
\medskip
    \[
        \inference{}{app(recfun(f.x.e_1), \square):P \prec v_1 \rightarrow_{h} P\succ [f:= fix(f.x.e_1),x:=v_1]}
    \]
$$$$
    % Si en el tope de la pila tenemos el marco $app( fun(x.e),\square)$ y re regresa el valor $v$ entonces evaluamos $e$ sustituyendo las apariciones de $x$ por $v$ en el resto de la pila.
    % \[
    %     \inference{}{app( fun(x.e_1),\square);P\prec v\rightarrow_{h}P\succ e[x:=v]}
    % \]
    \item[El operador de punto fijo] Para evaluar la expresión $ fix(f.e)$ en la pila $P$ se evalúa $e$ sustituyendo $f$ por $ fix(f.e)$.
    \[
        \inference{}{P\succ fix(f.e)\rightarrow_{h}P\succ e[f:= fix(f.e)]}
    \]
\end{description}
\end{definition}

\begin{exercise}[Ejecución máquina $\Hs$ con {\it marcos}] Para ver el funcionamiento de la máquina $\Hs$ vamos a evaluar la siguiente expresión:

\begin{lstlisting}
    let x = False in
        let y = 4 in
           if ( x then y + 1 else y - 1) 
        end
    end
\end{lstlisting}
En sintaxis abstracta:
$$let(\textsf{False},x.let(4,y.if(x,sum(y,1),sub(y,1)))))$$
La evaluamos en la máquina $\Js$.

\[
 \scalemath{0.85}{
    \begin{array}{rccl}
        \diamond & \succ & let(\textsf{False},x.let(4,y.if(x,sum(y,1),sub(y,1)))) & \rightarrow_{h} \\
	  let(\square,x.let(4,y.if(x,sum(y,1),sub(y,1)))):\diamond & \succ & \textsf{False} & \rightarrow_{h} \\
	  let(\square,x.let(4,y.if(x,sum(y,1),sub(y,1)))):\diamond & \prec & \textsf{False} & \rightarrow_{h} \\
        \diamond & \succ & let(4,y.if(x,sum(y,1),sub(y,1)))[x:=\textsf{False}] & \rightarrow_{h} \\
        \diamond & \succ & let(4,y.if(\textsf{False},sum(y,1),sub(y,1))) & \rightarrow_{h} \\
	  let(\square,y.if(\textsf{False},sum(y,1),sub(y,1))):\diamond & \succ & 4  & \rightarrow_{h} \\
	  let(\square,y.if(\textsf{False},sum(y,1),sub(y,1))):\diamond & \prec & 4  & \rightarrow_{h} \\
        \diamond & \succ & if(\textsf{False},sum(y,1),sub(y,1))[y := 4] & \rightarrow_{h} \\
        \diamond & \succ & if(\textsf{False},sum(4,1),sub(4,1)) & \rightarrow_{h} \\
        if(\square,sum(4,1),sub(4,1)):\diamond & \succ &\textsf{False} & \rightarrow_{h} \\
        if(\square,sum(4,1),sub(4,1)):\diamond & \prec &\textsf{False} & \rightarrow_{h} \\
        \diamond & \succ & sub(4,1) & \rightarrow_{h} \\
        sub(\square,1):\diamond & \succ & 4 & \rightarrow_{h} \\
        sub(\square,1):\diamond & \prec & 4 & \rightarrow_{h} \\
        sub(4,\square):\diamond & \succ & 1 & \rightarrow_{h} \\
        sub(4,\square):\diamond & \prec & 1 & \rightarrow_{h}\\
        \diamond & \succ & 4 - 1 & \rightarrow_{h} \\
        \diamond & \prec & 3 \\
    \end{array}
}
\]

\end{exercise}

\begin{exercise}[Ejecución máquina $\Hs$ con {\it marcos}] Para ver el funcionamiento de la máquina $\Hs$ vamos a evaluar la siguiente expresión:

\begin{lstlisting}
    let x = fun z -> z + 1 in
        let y = 4 in
           x y
        end
    end
\end{lstlisting}
En sintaxis abstracta:
$$let(fun(z.sum(z,1)),x.let(4,y.app(x,y)))$$
La evaluamos en la máquina $\Js$.

\[
 \scalemath{0.95}{
    \begin{array}{rccl}
         \diamond & \succ & let(fun(z.sum(z,1)),x.let(4,y.app(x,y))) & \rightarrow_{h} \\
	   let(\square,x.let(4,y.app(x,y))):\diamond & \prec & fun(z.sum(z,1)) & \rightarrow_{h} \\
         \diamond & \succ & let(4,y.app(x,y))[ x := fun(z.sum(z,1))] & \rightarrow_{h} \\
         \diamond & \succ & let(4,y.app(fun(z.sum(z,1)),y)) & \rightarrow_{h} \\
	  let(\square,y.app(fun(z.sum(z,1)),y)):\diamond & \succ & 4 &  \rightarrow_{h}\\
	  let(\square,y.app(fun(z.sum(z,1)),y)):\diamond & \prec & 4 &  \rightarrow_{h}\\
         \diamond & \succ & app(fun(z.sum(z,1)),y)[y := 4] & \rightarrow_{h} \\
         \diamond & \succ & app(fun(z.sum(z,1)),4) & \rightarrow_{h} \\
         app(\square, 4)\ : \diamond & \succ & fun(z.sum(z,1)) & \rightarrow_{h} \\
         app(\square, 4)\ : \diamond & \prec & fun(z.sum(z,1)) & \rightarrow_{h} \\
 	  app(fun(z.sum(z,1)),\square)\ : \diamond & \succ & 4 & \rightarrow_{h} \\
 	  app(fun(z.sum(z,1)),\square)\ : \diamond & \prec & 4 & \rightarrow_{h} \\
         \diamond & \succ & sum(z,1)[z := 4] & \rightarrow_{h} \\
         \diamond & \succ & sum(4,1) & \rightarrow_{h} \\
         sum(\square,1) : \diamond & \succ & 4 & \rightarrow_{h} \\
         sum(\square,1) : \diamond & \prec & 4 & \rightarrow_{h} \\
         sum(4,square) : \diamond & \succ & 1 & \rightarrow_{h} \\
         sum(4,square) : \diamond & \prec & 1 & \rightarrow_{h} \\
         \diamond & \succ & 4 + 1 & \rightarrow_{h} \\
         \diamond & \prec & 5  \\

    \end{array}
}
\]
\end{exercise}

\bigskip

\section{La máquina $\Js$}

La máquina $\Js$ es una extensión de la máquina $\Hs$ con la adición de un $cache$ para almacenar variables y sus valores al que denominamos entorno. Este entorno será el encargado de regresar el valor asociado a un atributo en las operaciones de sustitución (\textsf{let}, \textsf{lam}, \textsf{fix}, \textsf{fun}, \textsf{app}).
Esto con el objetivo de tener una implementación eficiente para la sustitución, operación que hasta el momento posee una complejidad lineal sobre el tamaño de la expresión que queremos evaluar.\\\\
Con pequeños ajustes podemos redefinir este nuevo modelo partiendo de las reglas definidas para $\Hs$ los cuales discutiremos a continuación.

\bigskip


\subsection{Marcos}

\begin{definition}[Marcos] En la máquina $\Js$ se usa el mismo conjunto de marcos que los presentados para la máquina $\Hs$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}.
\end{definition}



\subsection{Ambientes}

\begin{definition}[Ambientes] Un ambiente es una estructura que almacena asignaciones de variables con su valor y la definimos recursivamente como\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:
    \[
        \begin{array}{ccc}
            \inference{}{\bullet \ env}[{\ vacio}]&
            \qquad&
            \inference{x\;\;{\ var}&v\;\;{\ valor}&\bullet \ env}{x\leftarrow v\ ; \bullet \ env}[{\ asig}]
        \end{array}
    \]
    La forma de acceder a los elementos del ambiente es mediante el nombre de la variable, entonces si el ambiente $\E$ tiene la asignación $x\leftarrow v$. Podemos acceder al valor de $x$ como $\E[x]$ y el resultado es $v$. \\

    En caso de tener mas de una asignación sobre el mismo nombre de variable $\E [x]$ nos regresa la primera aparición de $x$ en el ambiente. Por ejemplo en el ambiente $\E  =_{def} x\leftarrow v_1;x\leftarrow v_2;\E$ la operación $\E [x]$ nos arroja como resultado $v_1$.
\bigskip
\end{definition}

\subsection{Estados}

\begin{definition}[Estados de la máquina $\Js$]
Los estados ahora son una relación ternaria de una pila de control $P$ un ambiente $\bullet $ y una expresión $e$, denotados como\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:\\
\begin{itemize}
    \item { Estados de evaluación: }$P\ |\ \E \succ e$
    \item { Estados de retorno: }$P\ |\ \E \prec e$\\
\end{itemize}

Un estado inicial es de la forma:
$$\diamond\ |\ \bullet \succ e$$\\
Mientras que los estados finales son de la forma:
$$\diamond\ |\ \E \prec v$$
Notemos que en los estados finales no importa que está guardado en el ambiente solo importa que la pila de control esté vacía.
\bigskip
\end{definition}

\subsection{Transiciones}

\begin{definition}Transiciones de variables en la máquina $\Js$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}}:\\

\begin{description}
    \item[Variables] En la máquina $\Hs$ una variable representa un estado bloqueado, pues no hay forma de continuar la evaluación del programa si no se aplica una operación de sustitución sobre la misma.\\\\
                            En la máquina $\Js$ no está definida la operación de sustitución. Tenemos que evaluar las variables buscándolas en el ambiente, lo que definimos con la siguiente regla:
    \[
        \inference{}{P\ |\ \E \succ x \to_{j} P\ |\ \E \prec\E [x]}
    \]
\end{description}
\end{definition}

Queremos utilizar los ambientes para introducir el concepto de alcance de una variable\footnote{Exploraremos de manera formal este concepto mas adelante en este capítulo.}. De manera informal el alcance de una variable es la porción del programa donde la definición de dicha variable es válida, por ejemplo en la expresión:

$$let(e_1,x.e_2 )$$

El alcance de $x$ solo estará definido para el cuerpo de la expresión $e_2$, una vez que se termine de evaluar la expresión $let$ queremos eliminar el ambiente donde la variable $x$ tiene una asignación para evitar repetir la misma en futuras evaluaciones pues el alcance donde es válida ya se ha terminado.\\\\
Para esto debemos extender la pila de los marcos para que pueda almacenar ambientes y deshacerse de ellos.
\begin{definition}Pila de control para $\Js$\footnote{Definición formulada de  \hyperlink{5}{[5]}, \hyperlink{8}{[8]} y  \hyperlink{12}{[12]}} 
\bigskip
    \[
        \begin{array}{ccccc}
            \inference{}{P\ pila}[{\sf vacia}]&
            \quad&
            \inference{m\ marco&P\ pila}{m;P\ pila}[{\sf top}]&
            \quad&
            \inference{\E \ env&P\ pila}{\E\ ; P\ pila}[{\sf top}]
        \end{array}
    \]
\bigskip

De esta forma cuando evaluemos una expresión que genera un ambiente distinto (llamémosle ambiente B), se guarda el ambiente actual en la pila de control (llamémosle ambiente A) y se definen las nuevas asignaciones dentro del ambiente B.\\\\
Una vez que termine la ejecución y se regrese un valor a la pila, recuperamos el ambiente A y continuamos con la ejecución del programa.
\end{definition}


\begin{definition}[Transiciones con alcance en la máquina $\Js$] Ahora reescribimos los casos que involucran usar sustitución para su evaluación.\\
\begin{description}
    \item[Asignaciones locales]
    \[  
        \begin{array}{c}
            \inference{}{P\ |\ \E \succ let(e_1,x.e_2) \to_{j} let(\square,x.e_2);P\ |\ \E \succ e_1}\\
            \\
            \inference{}{let(\square,x.e_2)\ ;\ P\ |\ \E \prec v\to_{j} \bullet\ ;\ P\ |\ x\leftarrow v\ ;\ \E \succ e_2}
        \end{array}
    \]
    \item[Aplicación de función] 
    \[
    \begin{array}{c}
        \inference{}{app(\square,e_2);P\ |\ \E \prec v_1\to_{j} app(v_1,\square);P\ |\ \E \succ e_2}\\
        \\
        \inference{}{app(fun(x.e_1),\square)\ ;\ P\ |\ \E \prec v_2 \to_{j} \E\ ;\ P\ |\ x\leftarrow v_2; \E \succ e_1}\\
        \\
        \inference{}{app(recfun(f.x.e_1),\square);P | E \prec v_2\to_{j} \E ;P | f\leftarrow fix(f.x.e_1) ; x\leftarrow v_2; \E \succ e_1}\\
    \end{array}
    \]
    \item[Liberación del ambiente] Esta regla se agrega para liberar el ambiente de la pila de control.
    \[
        \inference{}{\E ;P\ |\ \E_1\prec v\to_{j}P\ |\ \E \prec v}
    \]

Observemos como la evaluación del valor a almacenar en las asignaciones locales se volvió un punto estricto pues los ambientes solo almacenan valores.
\end{description}
\bigskip
\end{definition}

\begin{exercise}{Ejecución de la máquina $\Js$}
Tomemos como ejemplo la siguiente expresión de \textsf{MinHS}
    \begin{lstlisting}
            let f = fun x => x + y + z in
                let y = 4 in
                    let z = 10 in
                        f 1
                    end    
                end
            end    
    \end{lstlisting}

    La cual nos da la siguiente representación en sintaxis abstracta:

    $$ let(fun(y.sum(x,sum(y,z)),f.let(4,y.let(10,z.app(f,1)))) $$

    La evaluación en la máquina $\Js$ es de la siguiente forma:

    \[
    \scalemath{0.65}{
        \begin{array}{rcl}
            \diamond\ |\ \bullet & \succ & let(fun(y ... ))\\
            let(\square, f.let( ...)) : \diamond\ |\ \bullet & \succ & fun(y.sum(x,sum(y,z)))\\
            let(\square, f.let( ...)) : \diamond\ |\ \bullet & \prec & fun(y.sum(x,sum(y,z)))\\
            \diamond\ |\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & let(4,y.let(10,z.app(f,1))) \\
            \diamond\ | f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & let(4,y.let(10,z.app(f,1))) \\
            let(\square,y.let(10,z.app(f,1))) : \diamond\ |\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 4 \\
            let(\square,y.let(10,z.app(f,1))) : \diamond\ |\ \underline{f \leftarrow fun(x.sum(x,sum(y,z))) :\ \bullet}_{E_1} & \prec & 4 \\
            E_1\ :\ \diamond\ |\ y \leftarrow 4\ :\ f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & let(10,z.app(f,1)) \\
            let(\square, z,app(f,1)) : E_1 : \diamond\ |\ y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 10 \\
            let(\square, z,app(f,1)) : E_1\ : \diamond\ |\  \underline{y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet}_{E_2} & \prec & 10 \\
            E_2 : E_1 : \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & app(f,1) \\
            app(\square,1) : E_2 : E_1 :\ \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & f \\
            app(\square,1) : E_2 : E_1 :\ \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & fun(x.sum(x,sum(y,z)))\\
            app(\square,1) : E_2 : E_1 :\ \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & fun(x.sum(x,sum(y,z)))\\
            app(fun(y.sum(x,sum(y,z))),\square) : E_2 : E_1 :\ \diamond\ |\ z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 1\\
            app(fun(y.sum(x,sum(y,z))),\square) : E_2 : E_1 :\ \diamond\ |\ \underline{z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet}_{E_3} & \prec & 1\\
            E_3 : E_2 : E_1 :\ \diamond\ |\ y \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(y.sum(x,sum(y,z))) : \bullet & \prec & sum(x,sum(y,z))\\
            sum(\square,sum(y,z)) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & x\\
            sum(\square,sum(y,z)) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 1\\
            sum(\square,sum(y,z)) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 1\\
            sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & sum(y,z)\\
            sum (\square, z): sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & y\\
            sum (\square, z): sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 4\\
            sum (\square, z): sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & 4\\
            sum (4, \square): sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \succ & z\\
            sum (4, \square): sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 10\\
            sum(1,\square) : E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 4 + 10\\
            E_3 : E_2 : E_1 :\ \diamond\ |\ x \leftarrow 1 : z \leftarrow 10 :  y \leftarrow 4 : f \leftarrow fun(x.sum(x,sum(y,z))) : \bullet & \prec & 14 + 1\\
            E_2 : E_1 :\ \diamond\ |\ E:3 : \bullet & \prec & 14 + 1\\
            E_1 :\ \diamond\ |\ E_2 : \bullet & \prec & 15\\
            \diamond\ |\ E_1 : \bullet & \prec & 15\\
        \end{array}
    }
\]

\end{exercise}

\subsection{Alcance}
    Es importante detenernos a estudiar los diferentes alcances que la máquina $\Hs$ y la máquina $\Js$ introducen con su definición. Tomemos como ejemplo la siguiente expresión de \textsf{MinHS}

    \begin{lstlisting}
            let x = 0 in
                let x = 1in
                    sum(x,1)    
                end
            end    
    \end{lstlisting}

    Si evaluamos la expresión utilizando la definición de la máquina $\Hs$ el resultado será 1, dado que el alcance de esta máquina es estático, es decir, está limitado por la definición de los marcadores \textsf{in} y \textsf{let}. Esta implementación utiliza la operación de sustitución al evaluar un operador \textsf{let} por lo que obtendremos \textsf{sum(0,1) = 1}.\\\\
    Si por el contrario evaluamos la expresión con la definición de la máquina $\Js$ el resultado será 2 dado que esta máquina implementa un alcance dinámico, es decir, el alcance de las variables que definimos para ser sustituidas es todo el programa, así cuando encontramos una aparición de dicha variable se extrae del contexto el primer valor que coincida con el nombre. en este caso en el contexto tendremos $E= x \leftarrow 1 : x \leftarrow 0$ y la suma se evaluará como \textsf{sum(1,1) = 2}.

    \begin{definition}[Alcance estático] En los lenguajes que implementan el alcance estático, la porción del programa donde una variable está definida es la región en la cual se encuentra enmarcada\footnote{Los marcadores pueden ser bloques de indentación, marcadores de lugar como el operador \textsf{let, in, end}, cuerpo de una función etc.}. \footnote{Definición extraída de \hyperlink{2}{[2]} y \hyperlink{107}{[107]}}.
    \end{definition}
    
    \begin{definition}[Alcance dinámico] En un lenguaje con alcance dinámico, el alcance de un identificador es todo el programa, es decir, se toma la última asignación hecha al mismo\footnote{Definición extraída de  \hyperlink{2}{[2]} y \hyperlink{107}{[107]}}.
    \end{definition}

\subsection{Cerraduras}
    La descripción de alcances discutida anteriormente nos muestra un problema en la implementación de nuestras máquinas dado que los resultados obtenidos al evaluar la misma expresión son distintos. Esto se debe de corregir para la definición de la máquina $\Js$ mediante la definición de cerraduras que encapsulan el contexto de evaluación y la expresión para la que dicho contexto será aplicado cuando se evalúe.\\\\
    Los cerraduras nos ayudan a imitar la definición de un alcance estático en la implementación de $\Js$, para ésto deberemos modificar las reglas de evaluación.\\
    
    \begin{definition}[Cerraduras]
        Una {\it cerradura } es una pareja de una expresión de función de \textsf{MinHS} y un ambiente que se denota como:
        
        $$\ll \E,f \gg$$
        
        y se interpreta como, que el ambiente adecuado para evaluar la función $f$ es $\E$, de esta forma se respeta el ambiente en el que se define una función para usar el mismo en su ejecución y de esta forma definir una evaluación con alcance estático.
        \bigskip
    \end{definition}
        
        Ahora se modifican las transiciones definidas en la sección anterior para que usen {\it cerraduras} y modelen una evaluación con alcance estático, en lugar de la evaluación con alcance dinámico presentada anteriormente.
        
        \begin{definition}[Transición para funciones] En lugar de regresar las funciones como una expresión, se guardará como una pareja de la expresión y el ambiente en el que fue definido.
        \bigskip
        
        \[
            \begin{array}{c}
                \inference{}{P\ |\ \E \succ fun(x.e) \rightarrow_{j} P\ |\ \E \prec \ll \E,x.e \gg}\\
                \\
                \inference{}{app(\square,e_2); P\ |\ \E \prec \ll \E_f,x.e_1 \gg \rightarrow_{j} app(\ll \E_f,x.e_1\gg,\square); P\ |\ \E \succ e_2}\\
                \\
                \inference{}{app(\ll \E_f,x.e_1 \gg,\square); P\ |\ \E \prec v \rightarrow_{j} \E ; P\ |\ x\leftarrow v; \E_f \succ e_1}\\
                \\
                \inference{}{P\ |\ \E \succ recfun(f.x.e) \leftarrow_{j} P\ |\ \E \prec fix(f.\ll \E,x.e \gg)}\\
                \\
                \inference{}{app(\square,e_2); P | \E \prec fix(f.\ll ec_f,x.e_1\gg)\rightarrow_{j} appt(fix(f.\ll ec_f,x.e_1\gg),\square); P\ |\ \E \succ e_2}\\
                \\
                \inference{}{app(fix(f.\ll ec_f,x.e_1\gg),\square); P\ |\ \E \prec v \rightarrow_{j} \E; P\ |\ x\leftarrow v;f\leftarrow fix(f.closure{ec_f,x.e_1});ec_f\succ e_1}
            \end{array}
        \]
        \bigskip
        
        Con estas reglas se general los {\it cerraduras} en la evaluación de una función para que de esta forma el ambiente con el que se ejecutan en la aplicación sea el mismo ambiente en el que se definió la función y las variables tomen el valor esperado según el alcance estático.
        \bigskip
    \end{definition}

    \begin{exercise}
            \begin{lstlisting}
                let y = 4 in
                    let z = 10 in
                        let f = fun x => x + y + z in
                            f 1
                        end    
                    end
                end    
            \end{lstlisting}
    
        La cual nos da la siguiente representación en sintaxis abstracta:
    
        $$ let(4,y.let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1))))) $$
    
        La evaluación en la máquina $\Js$ es de la siguiente forma:
        \[
            \scalemath{0.55}{
                \begin{array}{rcl}
                    \diamond\ |\ \bullet & \succ &  let(4,y.let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1)))) \\
                    let(\square,y.let ... ) : \diamond\ |\ \bullet & \succ & 4 \\
                    let(\square,y.let ... ) : \diamond\ |\ \bullet & \prec & 4 \\
                    \bullet : \diamond\ |\ y \leftarrow 4 : \bullet & \succ & let(10,z.let(fun(x.sum(x,sum(y,z)),f.app(f,1))) \\
                    let(\square,z.let ... ) : \bullet : \diamond\ |\ y \leftarrow 4 : \bullet & \succ & 10 \\
                    let(\square,z.let ... ) : \bullet : \diamond\ |\ \underline{y \leftarrow 4 : \bullet}_{\ E_1} & \prec & 10 \\
                    E_1 : \bullet : \diamond\ |\ z \leftarrow 10 : E_1 & \succ & let(fun(x.sum(x,sum(y,z)),f.app(f,1)) \\
                    let(\square, f.app ...): E_1 : \bullet : \diamond\ |\ z \leftarrow 10 : E_1 & \succ & fun(x.sum(x,sum(y,z))) \\
                    let(\square, f.app ...): E_1 : \bullet : \diamond\ |\ \underline{z \leftarrow 10 : E_1}_{\ E_2} & \prec &  \ll E_2, fun(x.sum(x,sum(y,z))) \gg \\
                    E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \prec & app(f,1) \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \succ & f \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \succ &  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  \\
                    app(\square, 1) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \prec &  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  \\
                    app(\ll E_2, fun(y.sum(x,sum(y,z))) \gg, \square) :  E_2 : E_1 : \bullet : \diamond\ |\  f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2 & \succ &  1   \\
                    app(\ll E_2, fun(y.sum(x,sum(y,z))) \gg, \square) :  E_2 : E_1 : \bullet : \diamond\ |\  \underline{f \leftarrow  \ll E_2, fun(x.sum(x,sum(y,z))) \gg  : E_2}_{\ E_3} & \prec &  1   \\
                    E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & sum(x,sum(y,z)) \\
                    sum(\square, sum(y,z)) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & x \\
                    sum(\square, sum(y,z)) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ & x \\
                    sum(\square, sum(y,z)) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec & 1 \\
                    sum(1, \square ) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ : x \leftarrow 1  E_2 & \succ & sum(y,z) \\
                    sum(\square, z) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ y \\
                    sum(\square, z) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec 4 \\
                    sum(4, \square) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \succ z \\
                    sum(4, \square) : sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\  x \leftarrow 1 : E_2 & \prec 10 \\
                    sum(1, \square) : E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ : x \leftarrow 1 : E_2 & \prec 10 + 4 \\
                    E_3 :  E_2 : E_1 : \bullet : \diamond\ |\ : x \leftarrow 1 : E_2 & \prec 14 + 1 \\
                    E_2 : E_1 : \bullet : \diamond\ |\ E_3 & \prec 15 \\
                    E_1 : \bullet : \diamond\ |\  E_2 & \prec 15 \\
                    \bullet : \diamond\ |\ E_1 & \prec 15 \\
                    \diamond\ |\ \bullet & \prec 15 \\
                    
                \end{array}
            }
        \]
         
            Como podemos observar el resultado obtenido ahora es el mismo en ambas máquinas, evaluando a 15.
    \end{exercise}

    \bigskip
    
    De esta forma concluimos el estudio de la implementación de las máquinas abstractas para \textsf{MinHS}. A continuación se encuentran los ejercicios de comprensión para el lector.


    \section{Ejercicios para el lector}

    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
            \begin{lstlisting}
                let x = False in
                    let y = fun z => leq(z,0) in
                        let x = True in
                            if x then y 0 else False
                        end
                    end
                end  
            \end{lstlisting}

             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}

    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
            \begin{lstlisting}
                let recfun pow x = 
                    if x = 0 then 1 else x * pow x - 1 in
                        pow 3
                end        
            \end{lstlisting}

             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}

    \begin{exercise}
        Dada la siguiente expresión de \textsf{MinHS} contesta lo siguiente:
            \begin{lstlisting}
                let x = True in
                    let x = False in
                        if x then 1 else 0
                    end
                end   
            \end{lstlisting}

             \begin{itemize}
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Hs$.
                 \item Evalúa la expresión de acuerdo a la definición de la máquina $\Js$.
                 \item Los resultados obtenidos son los mismos o son diferentes?.
                 \item Evalúa la expresión utilizando la definición extendida para la máquina $\Js$ con cerraduras.
                 \item El resultado obtenido es el mismo?.
             \end{itemize}
    \end{exercise}   


%http://www.dcc.ic.uff.br/~isabel/LP/D.Watt.pdf
%file:///C:/Users/luismun/Downloads/Modern-Programming-Languages-A-Practical-Introduction%20(1).pdf
%file:///C:/Users/luismun/3D%20Objects/Desktop/Titulacion/Benjamin_C._Pierce-Types_and_Programming_Languages-The_MIT_Press(2002).pdf 
%file:///C:/Users/luismun/3D%20Objects/Desktop/Titulacion/Practical%20Foundations%20for%20Programming.pdf