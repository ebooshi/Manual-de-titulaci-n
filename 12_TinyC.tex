%    Noveno Capítulo: TinyC.
%    Ejercicios por Barón L. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 20/6/23
%    Concluido el 19/7/23

\begin{figure}[htbp]
    \centerline{\includegraphics[scale=.35]{assets/09_Gatito_C.png}}
\end{figure}

Hasta este punto en el manual hemos discutido la implementación de diferentes modelos de cómputo como \textsf{MinHS}, que nos fue de utilidad para ilustrar el paradigma funcional. La realidad es que muchos de los lenguajes que utilizamos actualmente no se implementan de esta forma.\\\\
Es aquí cuando haremos un cambio abrupto en nuestro caso de estudio para poner nuestra atención en el paradigma procedimental cuyo primer ejemplo será una implementación de un lenguaje de programación basado en \textsf{C} conocido como \textsf{TinyC}. Este tipo de lenguajes requieren del manejo de estados los cuales son afectados por el contexto del programa, los cambios en la memoria y las instrucciones que se ejecutan en un determinado momento.


\subsubsection{Objetivo}
En este capítulo comenzamos el estudio del paradigma procedimental, para esto nuestro interés principal será el de definir el primer caso de estudio conocido como \textsf{TinyC}. Proporcionando su sintaxis, reglas de transición y manejo de memoria.

\subsubsection{Planteamiento}
Se revisarán los componentes básicos del lenguaje \textsf{TinyC}, a saber: la sintaxis concreta y la semántica operacional mediante la implementación de la máquina $\Cs$. proporcionando una definición completa incluyendo marcos, estados y transiciones.
%Adicionalmente se discutirá la semántica estática de \textsf{TinyC} para asignar un tipo a los programas de este lenguaje.

\section{Sintaxis}

En \textsf{TinyC} tendremos las declaraciones de variables y funciones que se pueden identificar por nombre, las expresiones aritméticas y booleanas para construir la lógica de los programas y por último las sentencias encargadas de la ejecución y control del estado del programa.\\

\begin{definition}[Sintaxis Concreta de \textsf{TinyC}]\footnote{Definición formulada de \hyperlink{12}{[12]}, \hyperlink{126}{[126]}, y \hyperlink{127}{[127]} }.

	\footnote{De esta definición es importante notar la omisión entera de apuntadores dado que el \\
	tema escapa del enfoque de este capítulo quedándonos únicamente con un subconjunto \\
	de expresiones del lenguaje de programación \textsf{C}.}
    \[
        \begin{array}{rcl}
            \textsf{progam} &::=&\textsf{global-decs }\;\textsf{stmt}\\
            \textsf{global-decs} &::=&\varepsilon\ |\ \textsf{global-dec }\ \ \textsf{global-decs}\\
            \textsf{global-dec}&::=&\textsf{fun-dec}\ |\ \textsf{var-dec}\\
            \textsf{var-decs} &::=&\varepsilon\ |\ \textsf{var-dec }\;\textsf{var-decs}\\
            \textsf{var-dec}&::=&\textsf{type}\ \ \textsf{ident}=\textsf{expr };\\
            \textsf{fun-dec}&::=&\textsf{type}\ \ \textsf{ident}\;(\textsf{arguments})\ \ \textsf{stmt };\\
            \textsf{stmt}&::=&\textsf{expr };\ |\ \textsf{if}\ \ \textsf{expr }\ {\tt then}\ \ \textsf{stmt }{\tt else}\ \ \textsf{stmt };\ |\ \textsf{if}\ \ \textsf{expr }\ {\tt then}\ \ \textsf{stmt};\\
            &&\ | \ \textsf{return}\ \ \textsf{expr };\ |\ \{\textsf{var-decs }\ \textsf{stmts}\}\ |\ \textsf{while}\ (\textsf{expr})\ \ \textsf{stmt}\\
            \textsf{stmts} &::=&\varepsilon\ |\ \textsf{stmt }\ \ \textsf{stmts}\\
            \textsf{expr} &::=&\textsf{num}\ |\ \textsf{ident}\ |\ \textsf{asig}\ |\ \textsf{expr} + \textsf{expr}\ |\ \textsf{expr}\ -\ \textsf{expr}\\
            &&\ |\ \textsf{expr} > \textsf{expr}\ |\ \textsf{expr}\ <\ \textsf{expr}\ |\ \textsf{ident }(\textsf{exprs})\\
            \textsf{asig} &::=&\textsf{ident}=\textsf{expr}\\
            \textsf{exprs} &::=&\textsf{expr}\ |\ \textsf{expr},\textsf{exprs}\\
            \textsf{arguments} &::=&\varepsilon\ | \textsf{type}\ \ \textsf{ident},\textsf{arguments}\\
            \textsf{type}&::=&\textit{Int}\ |\ \textit{Bool}
        \end{array}
    \]

\end{definition}

Es importante remarcar el impacto que la introducción de las variables tienen en el estado de un programa para el paradigma procedimental. Dado que los variables representan locaciones de memoria, estas puede ser modificadas alterando así el estado mismo del programa en cualquier punto.  Esto no ocurría con la introducción de las variables en la sintaxis de orden superior para \textsf{MinHS} pues el valor ligado a una variable en este sistema permanece constante.

\bigskip

En \textsf{TinyC} los constructores del lenguaje se pueden agrupar en tres categorías:
\begin{itemize}
	\item \textbf{Declaraciones:} para especificar funciones, y asignar valores a variables.\\
	\item \textbf{Expresiones:} similares al paradigma funcional en el cual siempre regresan un valor una vez concluida la evaluación de la expresión.\\
	\item \textbf{Sentencias:} que son los constructores encargados de modelar los efectos del programa en el estado.\\\\
	Los programas en \textsf{TinyC} son una serie de declaraciones globales seguidas de una sentencia.
\end{itemize}

\begin{exercise}
    Escribe un programa en \textsf{TinyC} que implemente una función que nos permita calcular el enésimo número de la sucesión de Fibonacci.\\
    \begin{lstlisting}
        Int result = 0; 
        Int fibonacci(Int n){
        
            Int i = 1;
            Int pre = 1;
            Int post = 1;
            Int fib = 0;
            
            while(i < n){
                fib = pre + post;
                pre = post;
                post = fib;
            }
            return fib;
        };

        result = fibonacci(9);
    \end{lstlisting}
\end{exercise}

\section{La Máquina $\Cs$}

Para la semántica operacional de \textsf{TinyC} vamos a definir una máquina abstracta siguiendo la misma línea del capítulo anterior, donde contaremos con una pila para guardar los marcos de ejecución y cómputos pendientes, así como un contexto para las variables y los valores asignados a estas.

\subsection{Marcos}
En nuestro modelo de cómputo para \textsf{TinyC} vamos a heredar los marcos de las expresiones de la máquina $\Js$ dado que los elementos pertenecientes a la categoría $expr$ se comportan de forma análoga regresando un valor al concluir su evaluación. \\\\
De esta definición únicamente excluiremos a los marcos para funciones  ya que su comportamiento difiere entre ambas máquinas. En $\Js$ la declaración se hace mediante funciones anónimas que pueden ir en cualquier parte del programa, mientras que en en $\Cs$ deben ser declaradas antes de ser llamadas. Adicionalmente estas declaraciones de funciones pueden ser multiparamétricas mientras que en $\Js$ solo pueden declarase un argumento a la vez.

\begin{definition}[Marcos para la pila de control de la máquina $\Cs$]\footnote{Definición extraída de \hyperlink{12}{[12]} }.
\\*[11pt]
Se definen los siguientes marcos que usaremos en la pila de control de la máquina $\Cs$. Estos marcos corresponden a la evaluación de nuevas instrucciones como \textsf{return} que evalúa el contenido hasta obtener un valor, \textsf{secu} que nos ayuda a escribir una secuencia de instrucciones y \textsf{call} que es el equivalente a \textsf{app} de \textsf{MinHS}.
\\*[11pt]
    \begin{description}
        \item[Declaraciones] 
            \[
                \begin{array}{c}
                    \inference{}{vardec(T,x,\square)\ marco}
                \end{array}
            \]
        \item[Asignaciones] 
            \[
                \begin{array}{c}
                    \inference{}{asig(x,\square)\ marco}
                \end{array}
            \]
        \item[Secuencia]
            \[
                \begin{array}{c}
                    \inference{}{secu(\square,e_2)\ marco}
                \end{array}
            \]
        \item[Condicionales]
            \[
                \begin{array}{ccc}
                    \inference{}{if(\square,e_2,e_3)\ marco}&
                    \qquad&
                    \inference{}{if(\square,e_2)\ marco}
                \end{array}
            \]
        \item[Return]
            \[
                \begin{array}{c}
                    \inference{}{\ return(\square)\ marco}
                \end{array}
            \]
        \item[Llamada a función]
            \[
                \begin{array}{ccc}
                    \inference{}{\ call(f,\square,e_2,\dots,e_n)\ marco}&
                    \cdots&
                    \inference{}{\ call(f,v_1,v_2,\dots,\square)\ marco}
                \end{array}
            \]
    \end{description}
\bigskip
\end{definition}

\subsection{Estados}
Esta categoría introduce una diferencia sustancial con las máquinas abstractas hasta ahora estudiadas. Tendremos una categoría para la pila de cómputos pendientes y dos categorías para el contexto de evaluación de las variables, el primero local representando el alcance de las variables declaradas en el cuerpo de una función y el segundo global para aquellas declaraciones cuyo contexto sea todo el programa.

	\begin{definition}[Estados de la máquina $\Cs$]\footnote{Definición formulada de \hyperlink{5}{[5]}, y \hyperlink{8}{[8]} y \hyperlink{12}{[12]} }.
	     \\*[11pt]
		Los estados de la máquina $\Cs$ son de la siguiente forma:
			$$P \ |\ L \  |\ G \succ e\qquad\qquad P\ |\ L\ |\ G \prec e$$
		En donde $P$ es una pila de control, $L$ y $G$ son los ambientes local y global respectivamente y $e$ es una expresión en sintaxis abstracta de \textsf{TinyC}.
	\end{definition}

\subsection{Ambientes}
Los ambientes serán una lista de asignaciones de la forma: 
$$ \text{variable} \leftarrow \text{valor}$$
A continuación vamos a definir las funciones para hacer referencia al valor de una variable por nombre (búsqueda) y la función para modificar el contenido de una variable (actualización). \\

\begin{definition}[Referencia de variable en ambiente para la máquina $\Cs$]\footnote{Definición formulada de \hyperlink{5}{[5]}, y \hyperlink{8}{[8]} y \hyperlink{12}{[12]} }.

\[
    \begin{array}{ccccc}
        \inference{}{\bullet[x]=\ fail}&
        \quad&
        \inference{}{x\leftarrow v;\E[x] = v}&
        \quad&
        \inference{}{y\leftarrow v;\E[x] = \E[x]}
    \end{array}
\]
\\*[11pt]
Esta función itera sobre la lista de variables contenidas en el ambiente hasta hacer un $match$. Sí la búsqueda llega hasta la pila vacía esta regresa $fail$.

\end{definition}

\bigskip

\begin{definition}[Modificación del ambiente para una variable en la máquina $\Cs$]\footnote{Definición formulada de \hyperlink{5}{[5]}, y \hyperlink{8}{[8]} y \hyperlink{12}{[12]}}.

\[
    \begin{array}{ccc}
        \inference{}{\bullet[x \rightarrowtail v]= fail}&
        \quad&
        \inference{}{x\leftarrow u;\E[x \rightarrowtail v] = x\leftarrow v ;\E}
    \end{array}
\]
\[
    \begin{array}{c}
        \inference{}{y\leftarrow u;\E[x \rightarrowtail v] = \E[x \rightarrowtail v]}
    \end{array}
\]
\\*[11pt]
Esta función itera sobre la lista hasta hacer un $match$ y actualiza el valor contenido en esta variable. Sí la búsqueda llega hasta la pila vacía sin encontrar nada regresamos $fail$.
\end{definition}


\subsection{Transiciones}

\begin{definition}[Transiciones de la máquina $\Cs$]\footnote{Definición formulada de \hyperlink{5}{[5]}, y \hyperlink{8}{[8]} }
\\*[11pt]
Las transiciones de la máquina $\Cs$ se definen en términos de los programas que se están evaluando. Como vimos en secciones anteriores en el caso de \textsf{TinyC} un programa no tiene un resultado final, es decir no se reduce a un valor. Por lo que se agrega un programa especifico que indica el final de la ejecución, este programa es el programa vacío y se denota como:

$$\bot$$

Este define el final del proceso de evaluación de una sentencia, por lo que los estados finales de la máquina $\Cs$ son los que tienen la forma siguiente:

$$ \diamond\ |\ L\ |\ G\ \prec\ \bot$$

Se definen las transiciones con las siguientes reglas:\\
\begin{description}
    \item[Secuencia]
        \[
            \begin{array}{c}
                \inference{}{P\ |\ L\ |\ G\ \succ secu(e_1,e_2) \rightarrow_C secu(\square,e_2);P\ |\ L\ |\ G\ \succ e_1}\\
                \\
                \inference{}{secu(\square,e_2);P\ |\ L\ |\ G\ \prec \bot \rightarrow_C\ P\ |\ L\ |\ G\ \succ e_2}\\
                \\
            \end{array}
        \]
    \item[Declaraciones]
        \[
            \begin{array}{c}
            \inference{}{P\ |\ L\ |\ G\ \succ\ vardec(T,x,e)\rightarrow_C vardec(T,x,\square);\ P \ |\ L\ |\ G\ \succ e}\\
            \\
            \inference{G[x]=fail}{vardec(T,x,\square);P\ |\ L\ |\ G\ \prec v \rightarrow_C\ P\ |\ L\ | x \leftarrow v; G \prec \bot}\\
            \\
            \scalemath{0.9}{
                \inference{}{P | L | G \succ fundec(T,f,x_1:T_1.\cdots.x_n:T_n.e)\rightarrow_C P | L | f\leftarrow x_1.\cdots.x_n.e; G \prec \bot}
            }
            \\
            \end{array}
        \]
    \item[Asignación]
        \[
            \begin{array}{c}
            \inference{}{P\ |\ L\ |\ G \succ asig(x,e) \rightarrow_C\ asig(x,\square);P |\ L\ |\ G\ \succ e}\\
            \\
            \inference{G[x\rightarrowtail v]=G'}{asig(x,\square);P\ |\ L\ |\ G\ \prec v \rightarrow_C P\ |\ L\ |\ G' \prec \bot}\\
            \\
            \inference{G[x\rightarrowtail v]= fail& L[x\rightarrowtail v]=L'}{asig(x,\square);P\ |\ L\ |\ G\ \prec v \rightarrow_C P\ |\ L'\ |\ G \prec \bot}\\
            \\
            \end{array}
        \]
    \item[Variables]
        \[
            \begin{array}{c}
                \inference{G[x]=v}{P\ |\ L\ |\ G \succ x \rightarrow_C P\ |\ L\ |\ G \prec v}\\
                \\
                \inference{G[x]=fail&L[x]=v}{P\ |\ L\ |\ G \succ x \rightarrow_C P\ |\ L\ |\ G\ \prec v}\\
                \\
            \end{array}
        \]
    \item[Condicionales]
        \[
            \begin{array}{c}
                \inference{}{P\ |\ L\ |\ G\ \succ if(e_1,e_2,e_3) \rightarrow_C  if(\square,e_2,e_3);P\ |\ L\ |\ G\ \succ e_1}\\
                \\
                \inference{}{ if(\square,e_2,e_3);P\ |\ L\ |\ G\ \prec true \rightarrow_C P\ |\ L\ |\ G\ \succ e_2}\\
                \\
                \inference{}{ if(\square,e_2,e_3);P\ |\ L\ |\ G\ \prec false \rightarrow_C P\ |\ L\ |\ G\ \succ e_3}\\
                \\
                \inference{}{P\ |\ L\ |\ G\ \succ if(e_1,e_2) \rightarrow_C  if(\square,e_2);P\ |\ L\ |\ G\ \succ e_1}\\
                \\
                \inference{}{ if(\square,e_2);P\ |\ L\ |\ G\ \prec true \rightarrow_C P\ |\ L\ |\ G\ \succ e_2}\\
                \\
                \inference{}{ if(\square,e_2);P\ |\ L\ |\ G\ \prec false \rightarrow_C P\ |\ L\ |\ G\ \prec\bot}\\
                \\
            \end{array}
        \]
    \item[While]
        \[
            \begin{array}{c}
                \inference{}{P\ |\ L\ |\ G\ \succ while(e_1,e_2) \rightarrow_C P\ |\ L\ |\ G\ \succ  if(e_1, secu(e_2, while(e_1,e_2)))}\\
            \end{array}
        \]
        Esta regla traduce la evaluación de un $while\,$ a un $ if\,$ con un solo caso. Modela la siguiente regla equivalencia entre programas:
\\*[9pt]
        $$while(e_1)\{e_2\} \equiv if\,(e_1)\,\{\,e_2\,;\,while\,(e_1)\{\,e_2\,\}\}$$
	\\*[7pt]
        Observe como la expresión $while\,$ sigue apareciendo en el lado derecho. De esta forma se mantiene el ciclo tantas veces como se cumpla la condición.
\bigskip
    \item[Llamada a función]
        \[
            \begin{array}{c}
                \scalemath{0.9}{
                    \inference{}{P\ |\ L\ |\ G\ \succ call(f,e_1,\cdots,e_n) \rightarrow_C call(\square,e_1,\cdots,e_n);P\ |\ L\ |\ G\ \succ f}
                }
          \end{array}
        \]

        \[
	\begin{array}{c}
                \scalemath{0.8}{
                    \inference{}{call(\square,e_1,\cdots,e_n);P\ |\ L\ |\ G\ \prec v \rightarrow_C  call(v,\square,e_2,\cdots,e_n);P\ |\ L\ |\ G\ \succ e_1}
                }
          \end{array}
        \]
     
        \[        
	\begin{array}{c}
                \vdots\\
           
	     \scalemath{0.8}{
                    \inference{}{call(x_1.\cdots x_n.e,v_1,\cdots,\square);P\ |\ L\ |\ G\ \prec v_n \rightarrow_C  P\ |\ G\ \bigstar L \ |\  x_1\leftarrow v_1;\cdots;x_n\leftarrow v_n;\bullet \succ e}
                }
          	   \end{array}
	\]

	\bigskip

        Para la evaluación de una llamada a función, primero es necesario evaluar cada uno de los parámetros con los que se llama.\\\\
        Una vez que todos son valores, entonces se ejecuta el cuerpo de la función usando un ambiente vacío como ambiente principal y agregando a el los parámetros de la llamada. \\\\
        Guardamos el ambiente principal anterior con un símbolo especial ($\bigstar$) que sirve como separador para saber en donde termina uno y comienza el otro.

	\bigskip

        % \[
        %     \inference{}{\call(x_1.\cdots x_n.e,v_1,\cdots,\square);P\ |\ L\ |\ G\ \prec v_n \rightarrow_C  \pc\opc\gc\bigstar\lc\opc x_1\leftarrow v_1;\cdots;x_n\leftarrow v_n;\ee\succ e}
        % \]

        % Si el ambiente local no era vacío esto significa que hay llamadas a función anidadas, por lo cual no se puede hacer simplemente el swap de los ambientes ya que evaluaríamos la segunda llamada con el ambiente global. Entonces guardamos ambos ambientes con un símbolo especial ($\bigstar$) que sirve como separado para saber en donde termina uno y comienza el otro y definimos un nuevo ambiente local vacío como principal.
    \item[Return]
        \[
            \begin{array}{c}
                \inference{}{P\ |\ L\ |\ G\ \succ return(e) \rightarrow_C return(\square);\ P\ |\ L\ |\ G\ \succ e}\\
                \\
                \inference{}{return(\square); P\ |\ G\ \bigstar L_1\ |\ L_2 \prec v \rightarrow_C P\ |\ L_1\ |\ G\ \prec v}\\
                \\
                % \inference{}{\return(\square);\pc\opc\gc\opc\lc\prec v \rightarrow_C \pc\opc\ee\opc\gc\prec v}
            \end{array}
        \]
        El constructor $return\,$ indica el final de la ejecución de una llamada a función.\\\\
        Cuando termina la ejecución de una llamada a función. Se restaura el ambiente global y nos deshacemos del local pues solo era necesario dentro del cuerpo de la función.
\\*[11pt]
    \end{description}
\end{definition}

\begin{exercise}[Ejecución de la máquina C]
    Dado el siguiente programa de \textsf{TinyC}  Evalúa el programa para obeter el resultado de acuerdo a las reglas de transición y estados definidos en la sección anterior para la máquina $\Cs$:
    \begin{lstlisting}
        fibonacci(Int n){
        
            Int i = 1 ;
            Int pre = 1;
            Int post = 1;
            Int fib = 0;
            
            while(i < n){
                fib = pre + post;
                pre = post;
                post = fib;
                i++;
            }
            return fib;
        };

        Int result = fibonacci(3);
    \end{lstlisting}

	\bigskip

    Para facilitar la representación y la evaluación de la máquina $\Cs$ vamos a seccionar el programa para tener fragmenos de este, definimos entonces:

    \[
        A = secu(vardec(Int, i, 1), secu(vardec(Int, pre, 1), secu(vardec(Int, post, 1), vardec(Int, fib, 0))))
    \]
    \[
        B = secu(assig(fib, sum(pre,post)), secu(asig(pre,post), secu(asig(post,fib), asig(i,sum(i+1)))
    \]
	\\*[3pt]
        $ W = while(lt(i,n),B)) $\\
	\\*[4pt]
        $ F = fundec(Int,\ fibonacci,\ n:Int,\ secu(A,secu(W, return(fib)) $\\
	\\*[1pt]
       $ P = secu(F,vardec(Int, result, call(fibonacci, 3))) $

	\bigskip

	%En la escritura de los ejercicios también se optó por el renombramiento de los contextos cuando se necesita almacenar, modificar o agregar alguna definición de variable o función. \\
	%El contexto puede ser renombrado utilizando la notación $$\underline{v_1 \rightarrow n_1, ... , v_n \rightarrow n_k}_{L_n}$$

\[
\begin{turn}{270}
    \scalemath{0.55}{
        \begin{array}{rccl} 
            \diamond\ |\ \bullet\ |\ \bullet & \succ & secu(F,vardec(Int, result, call(fibonacci, 3)))  & \rightarrow_{\Cs} \\
            secu(\square,vardec(Int, result, call(fibonacci, 3))):\diamond\ |\ \bullet\ |\ \bullet & \succ & fundec(Int,\ fibonacci,\ n\ :\ Int, secu(A,secu(W, return(fib))) & \rightarrow_{\Cs} \\
            secu(\square,vardec(Int, result, call(fibonacci, 3))):\diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) \bullet & \prec & \bot & \rightarrow_{\Cs} \\
            \diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) \bullet & \succ & vardec(Int, result, call(fibonacci, 3)) & \rightarrow_{\Cs} \\
            vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) \bullet & \succ & call(fibonacci, 3) & \rightarrow_{\Cs} \\
            call(\square, 3) : vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) : \bullet & \succ & fibonacci & \rightarrow_{\Cs} \\
            call(\square, 3) : vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) : \bullet & \prec & n.secu(A,secu(W ...)) & \rightarrow_{\Cs} \\
            call(n.secu(A,secu(W ...)), \square) : vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ fibonacci \leftarrow n.secu(A,secu(W ...)) : \bullet & \succ & 3 & \rightarrow_{\Cs} \\
            call(n.secu(A,secu(W ...)), \square) : vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ \underline{fibonacci \leftarrow n.secu(A,secu(W ...)) : \bullet}_{L_1} & \prec & 3 & \rightarrow_{\Cs} \\
            vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ n \leftarrow 3 : \bullet & \succ & secu(A,secu(W ...)) & \rightarrow_{\Cs} \\
            secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ n \leftarrow 3 : \bullet & \succ &  secu(vardec(Int, i, 1), ...) & \rightarrow_{\Cs} \\
            secu(\square, secu(vardec(Int, pre ... ))) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ n \leftarrow 3 : \bullet & \succ &  vardec(Int, i, 1) & \rightarrow_{\Cs} \\
            vardec(Int, i, \square): secu(\square, secu(vardec(Int, pre ... ))) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ n \leftarrow 3 : \bullet & \succ &  1 & \rightarrow_{\Cs} \\
            secu(\square, secu(vardec(Int, pre ... ))) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ i \leftarrow 1 : n \leftarrow 3 : \bullet & \prec &  \bot & \rightarrow_{\Cs} \\
            secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & secu(vardec(Int, pre ... )) & \rightarrow_{\Cs} \\
            secu(\square, secu(vardec(Int, post ...))):secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & vardec(Int, pre, 1) & \rightarrow_{\Cs} \\
            vardec(Int, pre, \square) : secu(\square, secu(vardec(Int, post ...))):secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & 1 & \rightarrow_{\Cs} \\
            secu(\square, secu(vardec(Int, post ...))):secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet & \prec & \bot & \rightarrow_{\Cs} \\
            secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ pre \leftarrow 1 :i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & secu(vardec(Int, post ...))) & \rightarrow_{\Cs} \\
            secu(\square, vardec(Int, fib ... )) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ pre \leftarrow 1 :i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & vardec(Int, post, 1)  & \rightarrow_{\Cs} \\
            vardec(Int, post, \square) : secu(\square, vardec(Int, fib ... )) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ pre \leftarrow 1 :i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & 1 & \rightarrow_{\Cs} \\
            secu(\square, vardec(Int, fib ... )) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ post \leftarrow 1 : pre \leftarrow 1 :i \leftarrow 1 : n \leftarrow 3 : \bullet & \prec & \bot & \rightarrow_{\Cs} \\
            secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ post \leftarrow 1 : pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & vardec(Int, fib, 0) & \rightarrow_{\Cs} \\
            vardec(Int, fib, \square) : secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ post \leftarrow 1 : pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet & \succ & 0 & \rightarrow_{\Cs} \\
            secu(\square,secu(W ...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 0 : post \leftarrow 1 : pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet}_{L_2} & \prec & \bot & \rightarrow_{\Cs} \\
            vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & secu(while(lt(i,n),B), return(fib)) & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & while(lt(i,n),B) & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & if (lt(i,n), secu(B,while(...))) & \rightarrow_{\Cs} \\
            if(\square, secu(...)) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & lt(i,n) & \rightarrow_{\Cs} \\
           % if(\square, secu(...)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & lt(i,n) & \rightarrow_{\Cs} \\
       \end{array}
    } 
\end{turn}
\]
	
\[
\begin{turn}{270}
    \scalemath{0.65}{
        \begin{array}{rccl} 
	 lt(\square,n):if(\square, secu(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & i & \rightarrow_{\Cs} \\
            lt(\square,n):if(\square, secu(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & 1 & \rightarrow_{\Cs} \\
            lt(1,\square):if(\square, secu(...)) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & n & \rightarrow_{\Cs} \\
            lt(1, \square):if(\square, secu(...)) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & 3 & \rightarrow_{\Cs} \\
            if(\square, secu(...)) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & true & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\  L_2 & \succ & secu(B,while(...))) & \rightarrow_{\Cs} \\
            secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & secu(asig(fib,sum(pre,post) ...)) & \rightarrow_{\Cs} \\
            secu(\square , secu(asig(pre,post),...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & asig(fib,sum(pre,post))  & \rightarrow_{\Cs} \\
            asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & sum(pre,post) & \rightarrow_{\Cs} \\
            sum(\square,post): asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & pre & \rightarrow_{\Cs} \\
            sum(\square,post): asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & 1 & \rightarrow_{\Cs} \\
            sum(1,\square): asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \succ & post & \rightarrow_{\Cs} \\
            sum(1,\square): asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & 1 & \rightarrow_{\Cs} \\
            asig(fib,\square) : secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_2 & \prec & 2 & \rightarrow_{\Cs} \\
            secu(\square , secu(asig(pre,post),...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 2 : post \leftarrow 1 : pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet}_{L_3} & \prec & \bot & \rightarrow_{\Cs}  \\
            secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & secu(asig(pre,post),...)))  & \rightarrow_{\Cs} \\
            secu(\square, secu(asig(post...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & asig(pre,post)  & \rightarrow_{\Cs} \\
            assig(pre,\square):secu(\square, secu(asig(post...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & post & \rightarrow_{\Cs} \\
            assig(pre,\square):secu(\square, secu(asig(post...))) : secu(\square,while(...))) : secu(\square, return(fib)) :  vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \prec & 1 & \rightarrow_{\Cs} \\
            secu(\square, secu(asig(post...))) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \prec & \bot & \rightarrow_{\Cs} \\
          
            secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & secu(asig(post,fib), assig(i,sum(i,1))) & \rightarrow_{\Cs} \\
	 secu(\square, assig(i,sum(i,1)) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & asig(post,fib) & \rightarrow_{\Cs} \\
            asig(post,\square) : secu(\square, assig(i,sum(i,1)) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \succ & fib & \rightarrow_{\Cs}\\
	 asig(post,\square) : secu(\square, assig(i,sum(i,1)) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_3 & \prec & 2 & \rightarrow_{\Cs} \\
           secu(\square, assig(i,sum(i,1)) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 2 : post \leftarrow 2 : pre \leftarrow 1 : i \leftarrow 1 : n \leftarrow 3 : \bullet}_{L_4} & \prec & \bot\\

            secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \succ & assig(i,sum(i,1)) & \rightarrow_{\Cs} \\
            assig(i,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \succ & sum(i,1) & \rightarrow_{\Cs} \\
            sum(\square, 1):assig(i,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4& \succ & i & \rightarrow_{\Cs} \\
            sum(\square, 1):assig(i,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \prec & 1 & \rightarrow_{\Cs} \\
            sum(1, \square):assig(i,\square) :  secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \succ & 1 & \rightarrow_{\Cs} \\
            sum(1, \square) : assig(i,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \prec & 1 & \rightarrow_{\Cs} \\
            assig(i,\square) : secu(\square, asig(post,fib)) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \prec & 2 & \rightarrow_{\Cs} \\
            secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 2 : post \leftarrow 2 : pre \leftarrow 1 : i \leftarrow 2 : n \leftarrow 3 : \bullet}_{L_5} & \prec & \bot & \rightarrow_{\Cs} \\
            %secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \succ & asig(post,fib) & \rightarrow_{\Cs} \\
            %asig(post,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \succ & fib & \rightarrow_{\Cs}\\
        \end{array}
    } 
\end{turn}
\]

\[
\begin{turn}{270}
    \scalemath{0.6}{
        \begin{array}{rccl} 
            %asig(post,\square) : secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_4 & \prec & 2 & \rightarrow_{\Cs} \\
            %secu(\square,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 2 : post \leftarrow 2 : pre \leftarrow 1 : i \leftarrow 2 : n \leftarrow 3 : \bullet}_{L_5} & \prec & \bot\\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & while(lt(i,n),B) & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & if(lt(i,n), secu(B,while(...))) & \rightarrow_{\Cs} \\
            if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & lt(i,n) & \rightarrow_{\Cs} \\
            lt(\square, n):if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & i & \rightarrow_{\Cs} \\
            lt(\square, n):if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 2 & \rightarrow_{\Cs} \\
            lt(2, \square):if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & n & \rightarrow_{\Cs} \\
            lt(2, \square):if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 3 & \rightarrow_{\Cs} \\
            if(\square, secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & true & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & secu(B,while(...))) & \rightarrow_{\Cs} \\
            secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & secu(assig(fib,sum(pre,post),secu(...)) & \rightarrow_{\Cs} \\
            secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & assig(fib,sum(pre,post)) & \rightarrow_{\Cs} \\
            assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & sum(pre,post) & \rightarrow_{\Cs} \\
            sum(\square,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & pre & \rightarrow_{\Cs} \\
            %sum(\square,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 1 & \rightarrow_{\Cs} \\
%            sum(\square,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 1  & \rightarrow_{\Cs} \\
            sum(\square,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 1 & \rightarrow_{\Cs} \\
            sum(1,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \succ & post & \rightarrow_{\Cs} \\
            sum(1,post):assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 2 & \rightarrow_{\Cs} \\
            assig(fib,\square) : secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_5 & \prec & 3 & \rightarrow_{\Cs} \\
            secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 3 : post \leftarrow 2 : pre \leftarrow 1 : i \leftarrow 2 : n \leftarrow 3 : \bullet}_{L_6} & \prec & \bot & \rightarrow_{\Cs} \\
            %secu(\square,secu(asig(pre,post), ...)) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_6 & \prec & \bot & \rightarrow_{\Cs} \\
            secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_6 & \succ & secu(asig(pre,post), ...))) & \rightarrow_{\Cs} \\
            secu(\square, secu(asig(post, fib ...))) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_6 & \succ & asig(pre,post) & \rightarrow_{\Cs} \\
            asig(pre,\square): secu(\square, secu(asig(post, fib ...))) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_6 & \succ & post  & \rightarrow_{\Cs} \\
            asig(pre,\square): secu(\square, secu(post, fib, ...))) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_6 & \prec & 2 & \rightarrow_{\Cs} \\
            secu(\square, secu(asig(post, fib ...))) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 3 : post \leftarrow 2 : pre \leftarrow 2 : i \leftarrow 2 : n \leftarrow 3 : \bullet}_{L_7} & \prec & \bot & \rightarrow_{\Cs} \\
            secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_7 & \succ & secu(asig(post,fib), asig(i, sum(i,1))) & \rightarrow_{\Cs} \\
            secu(\square, asig(i, sum(i,1))): secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_7 & \succ & asig(post,fib) & \rightarrow_{\Cs} \\\
        \end{array}
    } 
\end{turn}
\]

\[
\begin{turn}{270}
    \scalemath{0.65}{
        \begin{array}{rccl} 
	  secu(\square, asig(i, sum(i,1))): secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            L_7 & \succ & asig(post,fib) & \rightarrow_{\Cs} \\
            asig(post, \square) : secu(\square, asig(i, sum(i,1))): asig(post, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            L_7 & \succ & fib & \rightarrow_{\Cs} \\
            asig(post, \square) : secu(\square, asig(i, sum(i,1))): asig(post, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            L_7 & \prec & 3 & \rightarrow_{\Cs} \\
             secu(\square, asig(i, sum(i,1))): secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 3 : post \leftarrow 3 : pre \leftarrow 2 : i \leftarrow 2 : n \leftarrow 3 : \bullet}_{L_8} & \prec 	& \bot \\

             secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \succ & asig(i,sum(i,1 )) & \rightarrow_{\Cs} \\
            asig(i, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \succ & sum(i,1) & \rightarrow_{\Cs} \\
          % asig(i, \square) : secu(\square, asig(post,fib))): secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \succ & sum(i,1) & \rightarrow_{\Cs} \\
            sum(\square,1) : asig(i, \square) :  secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \succ & 2 & \rightarrow_{\Cs} \\
            sum(\square,1) : asig(i, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \prec & 2 & \rightarrow_{\Cs} \\
            sum(2,\square) : asig(i, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \succ & 1 & \rightarrow_{\Cs} \\
            sum(2,\square) : asig(i, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \prec & 1 & \rightarrow_{\Cs} \\
            asig(i, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_8 & \prec & 3 & \rightarrow_{\Cs} \\
            secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            \underline{fib \leftarrow 3 : post \leftarrow 2 : pre \leftarrow 2 : i \leftarrow 3 : n \leftarrow 3 : \bullet}_{L_9} & \prec & \bot & \rightarrow_{\Cs} \\
           % secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            %L_8 & \succ & asig(post,fib) & \rightarrow_{\Cs} \\
            %asig(post, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            %L_8 & \succ & fib & \rightarrow_{\Cs} \\
            %asig(post, \square) : secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ 
            %L_8 & \prec & 3 & \rightarrow_{\Cs} \\
            %secu(\square, while(...)) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ \underline{fib \leftarrow 3 : post \leftarrow 3 : pre \leftarrow 2 : i \leftarrow 3 : n \leftarrow 3 : \bullet}_{L_9} & \prec & \bot \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & while(lt(i,n),B) & \rightarrow_{\Cs} \\
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & if(lt(i,n),secu(B,while(...)))& \rightarrow_{\Cs}  \\
            if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & lt(i,n) & \rightarrow_{\Cs} \\
            lt(\square, n) : if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & i & \rightarrow_{\Cs} \\
            lt(\square, n) : if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \prec & 3 & \rightarrow_{\Cs} \\
            lt(i, \square) : if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & n & \rightarrow_{\Cs} \\
            lt(i, \square) : if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \prec & 3 & \rightarrow_{\Cs} \\
            if(\square,secu(B,while(...))) : secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \prec & false & \rightarrow_{\Cs} \\    
            secu(\square, return(fib)) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \prec & \bot & \rightarrow_{\Cs} \\   
            vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & return(fib) & \rightarrow_{\Cs} \\  
            return(\square) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \succ & fib & \rightarrow_{\Cs} \\ 
            return(\square) : vardec(Int, result, \square) : \diamond\ |\ L_1 \bigstar \bullet\ |\ L_9 & \prec & 3 & \rightarrow_{\Cs} \\ 
            vardec(Int, result, \square) : \diamond\ |\ \bullet\ |\ L_1 & \prec & 3 & \rightarrow_{\Cs}\\ 
            \diamond\ |\  \bullet\ |\ result \leftarrow 3 : L_1 & \prec & \bot & \\ 
        \end{array}
    }
\end{turn}
\]
\end{exercise}

Nuestra atención está no en el resultado que se obtiene en el último paso ($\bot$) mas bien en el estado de la memoria. Óbserve que no regresamos el resultado al final de la evaluación si no que lo almacenamos en una de las variables que queda impresa en el contexto final. \\

\section{Ejercicios para el lector}

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición de un programa que dados dos enteros $n$ y $m$ revise que:
\[ n\ \% \ m\ ==\ 0 \]
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina $\Cs$ evalúa el ejercicio anterior con los valores 3 y 9.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición de un programa que dado un número $n$ revise su paridad.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina $\Cs$ evalúa el ejercicio anterior con el valor 4
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición de un programa que dados dos números $n$ y $m$ nos regrese el resultado de $n^m$.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina $\Cs$ evalúa el ejercicio anterior con los valores 3 y 2.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición del algoritmo $Merge\ Sort$.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina $\Cs$ evalúa el ejercicio anterior con el arreglo [7,5,1,3]
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición del algoritmo $Binary\ Search$.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina $\Cs$ evalúa el ejercicio anterior con el arreglo [8,4,1,2,7] y  2.
\end{exercise}


\bigskip

\begin{exercise}
    Utilizando la sintaxis definida para \textsf{TinyC} proporciona la definición de un programa que calcule el n-ésimo término de la sucesión de Cataluña.
\end{exercise}

\bigskip

\begin{exercise}
    Utilizando la definición de la máquina C evalúa el ejercicio anterior con el número 7
\end{exercise}

