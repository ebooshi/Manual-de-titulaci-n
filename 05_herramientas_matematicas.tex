
%    Segundo capítulo: Herramientas Matemáticas.
%    Ejercicios por Barón M. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 21/10/22
%    Concluido el 25/10/22

%Gatito Constructor
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=.19]{assets/02_gatito_herramientas_matematicas.jpg}}
    \label{fig 1. Mapa para clasificar los lenguajes de programación.}        
\end{figure}

Para estudiar a los lenguajes de programación es necesario definir una estructura que nos permita capturar su esencia matemática y nos proporcione un mecanismo para demostrar características y propiedades asociadas a estos. \\\\
Una manera de definir formalmente un lenguaje de programación es mediante la aplicación de juicios lógicos para definir propiedades, pertenencia de los elementos de la estructura a un conjunto, relaciones entre diferentes elementos, etc\footnote{Para las personas que poseen una madurez matemática superior a aquella que la que un estudiante de cuarto semestre de la Facultad de Ciencias pudiera tener se recomienda encarecidamente iniciar el estudio de este manual en el \hyperref[sec:sintax]{capítulo 3: Sintaxis}. Los temas recomendados para omitir los primeros dos capítulos del manual son: estructuras discretas, juicios lógicos, reglas de inferencia e inducción estructural. }. \\
\subsection*{Objetivo}
Estudiar las estructuras matemáticas que utilizaremos para familiarizarnos con el concepto de inducción estructural. En particular centraremos nuestra atención a estructuras recursivas como listas de tipo A y árboles binarios balanceados de tipo A\footnote{donde A es un conjunto o una colección de elementos.} junto con las reglas que nos permiten construir estas estructuras.\\\\
Este tipo de mecanismos es particularmente útil para ilustrar las propiedades de los lenguajes que definiremos a lo largo de los capítulos de este manual.

\subsection*{Planteamiento}
En este capítulo exploraremos diferentes estructuras matemáticas, empezando por los juicios lógicos. Estos constituyen las entidades fundamentales sobre las cuales iniciaremos el estudio de los lenguajes.
También estudiaremos brevemente estructuras recursivas como cadenas y listas para enunciar el principio de inducción que nos permite demostrar propiedades sobre dichas estructuras.\\\\ Por último estudiaremos un sistema de transición para modelar los estados y reglas de evaluación de la instancia de un juego.

%    Sección 1: Juicios lógicos.
\section{Juicios lógicos}

    Una parte fundamental del razonamiento matemático es la capacidad de determinar si una afirmación es verdadera o falsa basado en la información que poseemos sobre los elementos que son mencionados en dicha afirmación. \\\\
    Para poder aplicar un juicio sobre algún elemento, objeto o entidad para determinar su veracidad primero debemos definir dichos elementos. A continuación vamos a introducir los conceptos necesarios para poder formalizar esta noción y el cómo aplicarla. Esto será de utilidad para definir características, reglas de construcción y reglas de evaluación en los lenguajes de programación y modelos de computo que discutiremos a lo largo del manual.\\

    \bigskip

    % Ejercicio 1.1
    \begin{definition}
	¿Qué es una entidad matemática? \\ 
	  En el lenguaje habitual de las matemáticas, una entidad es cualquier cosa que ha sido definida formalmente y con la que se pueden realizar razonamientos deductivos y pruebas matemáticas\footnote{Definición formulada de \hyperlink{58}{[58]}, \hyperlink{59}{[59]} y \hyperlink{60}{[60]}}.
    \end{definition}

\bigskip

    % Ejercicio 1.2
    \begin{definition}
	¿Qué es un juicio? \\
         En lógica matemática, un juicio es una afirmación o enunciación de una característica o propiedad sobre un objecto o elemento de un dominio\footnote{Definición formulada de \hyperlink{61}{[61]} y \hyperlink{62}{[62]}}.
    \end{definition} 

\bigskip

Los juicios que denotan que un objeto $x$ cumple con la propiedad $P$ usualmente son escritos utilizando notación posfija, como $x\ P$.\\\\
Aquellos juicios que se aplican sobre relaciones y operadores binarios, usualmente son escritos con notación infija como en el caso de la relación de igualdad  $x\ =\ y$.

    % Ejercicio 1.3
    \begin{exercise}
	Proporciona un listado de juicios sobre objetos matemáticos (Puedes suponer definidos con anterioridad elementos como $\mathbb{N}$, $\mathbb{Q}$, $Bool$, \textit{String}, funciones, relaciones de orden, operadores aritméticos, etc). 
	\begin{center}
		\begin{tabular}{rl}
			 ''Hola Mundo'' \textbf{$String$} & La cadena  ''Hola Mundo'' es de tipo $String$.  \\
			L \textbf{$NP$} & El lenguaje L es $NP$. \\
			\textit{a} $\textgreater$ \textit{b} & el número $a$ es más grande que el número $b$. \\
			A $|$ B  & El evento A es independiente al evento B. \\
			\textsf{true} $Bool$  & La constante \textsf{true} es de tipo $Bool$.  \\
			h = \( g \circ f \) & la función $h$ es la composición de la función $g$ con la función $f$.\\
			3.1416... $\mathbb{I}$ & El número 3.1416... es  irracional \\
			0 $\mathbb{N}$  & 0 es un Natural. \\
			S(0) impar & El sucesor de 0 es impar.\\
			$\frac{p}{q}$  $\mathbb{Q}$  & La fracción $\frac{p}{q}$ es un número racional.\\
			...
		\end{tabular}
	\end{center}
    \end{exercise}

\bigskip

%    Sección 2: Reglas de Inferencia, Inducción estructural.
\section{Reglas de inferencia}

    Las reglas de inferencia\footnote{En esta manual utilizaremos el término  ''regla de inferencia '' o  ''juicio lógico '' de forma indistinta.} son una representación de la aplicación de un juicio de la forma:  ''Si las premisas $p_1,p_2,\ ...\ p_n$ son verdaderas, entonces $c$ es verdadero.''\\
Visualmente esto se denota como:\\
\[
        \inference{p_1,p_2,\ ...\ p_n}{\textit{c}}
    \]

    Podemos observar que las reglas de inferencia están compuestas por dos secciones: una sección superior y una inferior. 
    La sección superior es en donde se agrupan las condiciones necesarias para que la regla pueda ser aplicada (a los elementos enlistados en esta parte se les conoce como premisas o hipótesis), cada una de estas están separadas por una coma (',') y todas deben de cumplirse\footnote{El signo de puntuación (',') se puede interpretar como el operador $\wedge$ donde cada hipótesis es un argumento de dicho operador.}. \\\\
    La sección inferior de una regla de inferencia enlista el resultado de la aplicación de la regla a las premisas. Ocasionalmente la regla tendrá un nombre que ayuda a identificar cuál de ellas es aplicada cuando se trabaja con derivaciones y razonamientos\footnote{Definición formulada de \hyperlink{1}{[1]}, \hyperlink{5}{[5]}, \hyperlink{9}{[9]}, \hyperlink{63}{[63]}, \hyperlink{64}{[64]} y \hyperlink{91}{[91]}.}. En esta sección de la regla puede haber uno o más elementos resultados de la aplicación pero no puede ser vacía. \\\\
    Los axiomas son las reglas de inferencia que carecen de hipótesis dado que siempre serán verdad y no es necesario suponer nada para concluirlos.\\\\
    Tomemos como ejemplo la definición de las cadenas binarias de tipo A (denominaremos a este tipo de dato como A*) para ilustrar las reglas de inferencia y sus partes anteriormente discutidas.

\bigskip

    % Definición: Cadenas Binarias y función de concatenación.
    \begin{definition}
        Sea $\text{A} = \{ 0,1 \}$ (\textit{def}), definimos el tipo de dato recursivo $\text{A}^*$ \footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}} como sigue: \\\\
            \[
                \begin{array}{lcl}    
                    \inference{}{\varepsilon \  \text{A}^*}[\textit{(eps)}] \qquad 
                    \inference{a \ \text{A},\; s \ \text{A}^*}{\<a, s\> \ \text{A}^*}[\textit{(tup)}]
                \end{array}
            \] 

	\bigskip

            La regla \textit{eps} se lee como:  ''la cadena vacía es una cadena binaria de tipo A.'' Nótese que esta regla es un axioma dado que carece de premisas. \\\\
            La regla \textit{tup} se lee como:  ''si \textit{a} es de tipo A y \textit{s} es una cadena binaria de tipo A, entonces la construcción de una tupla con cabeza \textit{a} y cola \textit{s} es una cadena binaria de tipo A.''\\\\
            Por ejemplo, la cadena 10101 se representa por la 5-tupla $\<1,\<0,\<1,\<0,\<1,\ \epsilon \>\>\>\>\>$ 
    \end{definition}

\bigskip

Es importante notar que las reglas de inferencia son puramente sintácticas. Por ejemplo, el número "00011" no puede ser generado directamente por las reglas de A*. Su representación como cadena binaria sí: $\<0,\<0,\<0,\<1,\<1,\ \epsilon \>\>\>\>\>$. El conjunto de reglas de inferencia de A* no posee alguna que nos ayude a formular los números binarios sin la aplicación de las tuplas. \\\\
Ahora que hemos definido una estructura de datos con reglas de inferencia, es natural preguntarse "¿cómo razonar sobre esta?". Por ejemplo como demostrar que\footnote{Aquí estamos haciendo abuso de notación con la aplicación de $\in$ para hacer explícita la propiedad para el primer caso y denotar que para el segundo no es válida.}: $$\<0,\<0,\<0,\<1,\<1,\ \epsilon \>\>\>\>\> \in \text{A}^*$$   $$\<0,\<7,\<4,\<1,\ \epsilon \>\>\>\> \notin \text{A}^*$$\\
Las reglas de inferencia pueden ser utilizadas tanto para definir una propiedad como para demostrar que esta propiedad se cumple. \\\\
Si queremos demostrar que un juicio $J$ es válido, tenemos que encontrar una regla que tenga a $J$ como conclusión. Si la regla es un axioma entonces nuestra prueba está concluida. Si la regla contiene premisas $p_1, ..., p_n$ entonces hay que aplicar la misma estrategia de forma recursiva donde la premisa $p_x$ con $x \in \{1, .., n\}$ figure como conclusión de alguna regla. \\ \\
Si en algún punto de la derivación no podemos aplicar ninguna regla y esa premisa no se corresponde con un axioma entonces no se puede demostrar que la propiedad se cumple.\\\\
Ejemplifiquemos esto con el siguiente ejercicio. 

    \bigskip

\newpage
% Ejercicio 2.2
    \begin{exercise}
        Utiliza las reglas (\textit{eps}) y (\textit{tup}) para derivar la cadena
        \[
             \<1,\<0,\<0,\varepsilon\>\>\>, \qquad
             \<1,\<0,\<0\<1,\varepsilon\>\>\>\> \qquad y \qquad
             \<1,\<1,\<1,\<0,\<1,\<0,\varepsilon\>\>\>\>\>\>
        \] 
        \bigskip


\begin{turn}{90}
        \scalemath{0.75}{
            \begin{array}{cc}

			\\ \\ \\ \\ \\  
                \inference{\inference{}{1 \ \text{A}}[(\textit{def})] \inference{\inference{}{0 \  \text{A}}[(\textit{def})]& \inference{\inference{}{0 \ \text{A}}[(\textit{def})]& \inference{}{\varepsilon \ \text{A}^*}[(\textit{eps})]}{\<0, \varepsilon \>\  \text{A}^*}[(\textit{tup})]}{\<0,\<0,\varepsilon\>\> \ \text{A}^*}[(\textit{tup})]}{\<1,\<0,\<0,\varepsilon\>\>\> \ \text{A}^*}[(\textit{tup})] \\ \\ \\ \\ \\ \\ \\
        
                \inference{\inference{}{1 \ \text{A}}[(\textit{def})]& \inference{\inference{}{0 \ \text{A}}[(\textit{def})]& \inference{\inference{}{0 \ \text{A}}[(\textit{def})]& \inference{\inference{}{1 \ \text{A}}[(\textit{def})]& \inference{}{\varepsilon \ \text{A*}}[(\textit{eps})]}{\<1,\varepsilon\> \ \text{A}^*}[(\textit{tup})]}{\<0,\<1,\varepsilon\>\> \ \text{A}^*}[(\textit{tup})]}{\<0,\<0,\<1,\varepsilon\>\>\> \ \text{A}^*}[(\textit{tup})]}{\<1,\<0,\<0,\<1,\varepsilon\>\>\>\> \ \text{A}^*}[(\textit{tup})] \\ \\ \\ \\ \\ \\ \\


                \inference{\inference{}{1 \ \text{A}}[(\textit{def})] \inference{\inference{}{1 \ \text{A}}[(\textit{def})]&  \inference{\inference{}{1 \ \text{A}}[(\textit{def})]&  \inference{\inference{}{0 \  \text{A}}[(\textit{def})]&  \inference{\inference{}{1 \ \text{A}}[(\textit{def})]& \inference{\inference{}{0 \ \text{A}}[(\textit{def})]& \inference{}{\varepsilon \ \text{A}^*}[(\textit{eps})]}{\<0,\varepsilon\> \ \text{A}^*}[(\textit{tup})]}{\<1,\<0,\varepsilon\>\> \ \text{A}^*}[(\textit{tup})]}{\<0,\<1,\<0,\varepsilon\>\>\> \ \text{A}^*}[(\textit{tup})]}{\<1,\<0,\<1,\<0,\varepsilon\>\>\>\> \ \text{A}^*}[(\textit{tup})]}{\<1,\<1,\<0,\<1,\<0,\varepsilon\>\>\>\>\> \ \text{A}^*}[(\textit{tup})]}{ \<1,\<1,\<1,\<0,\<1,\<0,\varepsilon\>\>\>\>\>\> \ \text{A}^*}[(\textit{tup})]
            \end{array}  
        }

\end{turn}
    \end{exercise}


\section{Estructuras recursivas e inducción estructural}

    Ahora discutamos un tipo de estructuras particulares que se relacionan de forma íntima con los conceptos anteriormente planteados; las estructuras recursivas\footnote{Definición formulada a partir de \hyperlink{91}{[91]}, \hyperlink{92}{[92]} y \hyperlink{93}{[93]}}. Estas se generan a partir de dos casos:
    \begin{itemize}
 
        \item La estructura está compuesta por un elemento primitivo. Muchas veces estos elementos constituyen la clausula de escape para la recursión inducida por la definición y darán lugar a uno o más axiomas en su representación como regla de inferencia.
        \item La estructura está compuesta por una llamada a la función constructora con un elemento nuevo y la estructura misma que se desea definir como argumentos. 
    \end{itemize}


    En el caso del tipo de dato A*, el elemento primitivo que pertenece a esta estructura es la cadena vacía (denotada como $\varepsilon$). Los elementos compuestos se generan por una tupla con cabeza \textit{a} A y cola de tipo A*.\\\\
    Este principio es válido tanto para definir la estructura recursiva como para las funciones que se quieran aplicar sobre la misma\footnote{Información obtenida de \hyperlink{94}{[94]} y \hyperlink{95}{[95]}}. Para ilustrar este punto definimos la función para concatenar dos elementos de A* de la siguiente forma: 
    \begin{definition}[Concatenación de cadenas de A*]
        Definimos la concatenación de cadenas A* denotada como: $\bullet$ ::\ (A* $\rightarrow$\ A*) $\rightarrow$\ A* mediante la siguiente especificación\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]}}:
        \[
            \begin{array}{rcl}
                \text{Caso base:}   & \varepsilon \bullet t  =   t & \\
                \text{Constructor:} & \<a,s\> \bullet t  =  \<a,\<s \bullet t\>\> & 
            \end{array}
        \]
    \end{definition}
    La característica mas importante que las estructuras recursivas poseen es el principio de inducción. Esta propiedad nos permite demostrar que una proposición o propiedad es válida para cualquier elemento de la estructura mediante su aplicación de la siguiente forma:
    \begin{itemize}
        \item Se demuestra la validez de la proposición para los elementos primitivos.
        \item Posteriormente se asume que la propiedad es válida para cualquier instancia. 
        \item Por último se demuestra la propiedad aplicada para los constructores que generan instancias más grandes aplicando la hipótesis del inciso anterior.
    \end{itemize}
    \bigskip

    % Ejercicio 2.1
    \begin{exercise}
        Utiliza la inducción estructural para demostrar: 
        \[ t \bullet \varepsilon = t\] 
            \textbf{Caso Base} t = $\varepsilon$ \\
		 $t \bullet \varepsilon = \varepsilon \bullet \varepsilon$\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad  \qquad \qquad \qquad  \qquad \qquad  (Por hipótesis)\\
            $\varepsilon \bullet \varepsilon$ =  $\varepsilon$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad (Por la definición de $\bullet$) \\
            $\varepsilon$ = $t$. \\\\
            \textbf{Hipótesis Inductiva} $t \bullet \varepsilon = t$, $\forall$ $t \in \text{A}^*$ \\\\
            \textbf{Paso Inductivo} Por demostrar para t' = $\<a,t\>, a \in \text{A}$, $t \in \text{A}^*$ \\
            $\<a,t\> \bullet \varepsilon$ = $\<a, \<t \bullet \varepsilon \> \>$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad \quad (Por la definición de $\bullet$) \\
            $\<t \bullet \varepsilon \> = t $ \qquad \qquad \qquad \qquad \qquad \quad \qquad \qquad \qquad \qquad \qquad\ (Por la hipótesis inductiva) \\
            $\<a,t\> \bullet \varepsilon = \<a, \<t \bullet \varepsilon \> \> = \<a, t\>$ \\ 
    \end{exercise}


    % Definición 2.2: Función para contar caracteres
    \begin{definition}
        Definimos la función para contar ocurrencias de los carácteres 1 ó 0 en una cadena denotada por $numChar$ :: (A $\rightarrow$ A*) $\rightarrow$ Int como sigue\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}} :
        \[   
            numChar(c, \ \<a,t\>) = 
                \begin{cases}
                    numChar(c, \ \varepsilon) = 0 \\
                    1 + numChar(c, \ t) & \text{Sí \textit{a} = c} \\
                    numChar(c, \ t)     & \text{Sí \textit{a}} \neq c \\
                 \end{cases}
        \]
    \end{definition}
Cuando se quiera aplicar el principio de inducción a una función o propiedad que recibe mas de un argumento, la inducción se tiene que fijar sobre alguno de sus parámetros. Ejemplifiquemos esto con el siguiente ejercicio.

    % Ejercicio 2.3
    \begin{exercise}
        Utiliza la inducción estructural para demostrar

           \[ numChar(c, s \bullet t) = numChar(c, s) + numChar(c, t)  \]

	 \textbf{Demostración por inducción sobre }$s$.\\\\
        \textbf{Caso Base} $s = \varepsilon$ \\
		$numChar(c, s \bullet t) = numChar(c, \varepsilon \bullet t)$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad  (Por hipótesis)\\
             $numChar(c, \varepsilon \bullet t) = numChar(c, t)$ \qquad \qquad \qquad \qquad \qquad \quad \quad(Por la definición de $\bullet$)\\
             $0 + numChar(c, t)$ = $numChar(c, \varepsilon) + numChar(c, t)$ \quad  (Por la definición de $numChar$)\\
             = $numChar(c, s) + numChar(c, t)$\\

        \textbf{Hipótesis Inductiva}  $numChar(c, s \bullet t) = numChar(c, s) + numChar(c, t), \forall  s,t  \in $ A*\\

        \textbf{Paso Inductivo} Por demostrar para $s' = \<a,s\>, a \in $ A, $s \in $A*\\
            $numChar(c, \<a,s\> \bullet t)$ = $numChar(c, \<a, s \bullet t \>)$ \qquad \qquad \qquad \quad (Por la definición de $\bullet$)\\
            
        \textbf{Caso 1} $a = c$ entonces tenemos\\
             $numChar(c, \<a, s \bullet t \>)$ = $1 + numChar(c, s \bullet t ) $ \qquad \quad \quad (Por la definición de $numChar$) \\
            = $1 +  numChar(c, s) +  numChar(c, t)$ \qquad \qquad \qquad \qquad \quad (Por la hipótesis inductiva) \\
	     = $numChar(c, \<a,s\>) +  numChar(c, t)$ \qquad \qquad \qquad \quad (Por la definición de $numChar$) \\

        \textbf{Caso 2} $a \neq c$ entonces tenemos \\
             $numChar(c, \<a, s \bullet t \>)$ = $numChar(c, s \bullet t )$ \qquad \qquad \quad  (Por la definición de $numChar$) \\
            = $numChar(c, s) +  numChar(c, t)$ \qquad \qquad \qquad \qquad \qquad \quad (Por la hipótesis inductiva) \\
		   %= $0 + numChar(c, s) + numChar(c, t)$ \\
            = $numChar(c, \<a,s\>) +  numChar(c, t)$ \qquad \qquad \qquad \quad (Por la definición de $numChar$) 
            
    \end{exercise}
    
    % Definición 2.3: funcion de reversa y longitud para cadenas de caracteres.
    \begin{definition}
        Definimos las funciones $rev$ :: A* $\rightarrow$ A* y $len$ :: A* $\rightarrow$ Int para obtener la reversa y la longitud\footnote{Definición formulada a partir de \hyperlink{67}{[67]} y \hyperlink{70}{[70]} } de los elementos de A* respectivamente como:
        \[
            rev(\varepsilon) = \varepsilon  \qquad
            rev(\<a,s\>) = rev(s) \bullet \<a, \varepsilon\>  
        \]
        \[
            len(\varepsilon) = 0 \qquad
            len(\<a,s\>) = 1\ +\ len(s) 
        \]
    \end{definition}

    % Ejercicio 2.4
    \begin{exercise}
        Utiliza inducción estructural para demostrar
            \[ len(s \bullet t) = len(s) + len(t) \]
    	\textbf{Demostración por inducción sobre } $s$.\\\\
	        \textbf{Caso Base } $s = \varepsilon$ \\
	   $len(s \bullet t) = len(\varepsilon \bullet t)$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad  (Por la hipótesis)
           $len(\varepsilon \bullet t) = len(t)$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad \quad \quad \quad (Por la definición de $\bullet$) \\
           = $0 + len(t)$ = $len(\varepsilon) + len(t)$ \qquad \qquad \qquad \qquad \qquad \quad \quad \quad \quad (Por la definición de $len$) \\
           = $len(s) + len(t)$\\\

        \textbf{Hipótesis inductiva }  $len(s \bullet t) = len(s) + len(t) \ \forall s,t \in $ A*\\  

        \textbf{Paso Inductivo } Por demostrar para $s' = \<a,s\>$, \textit{a} $\in$ A y \textit{s} $\in$ A*\\
            $len(\<a,s\> \bullet t) = len(\<a,\<s \bullet t\>\>)$ \qquad \qquad \qquad \qquad \qquad \quad \quad \quad \quad \quad \ \ (Por la definición $\bullet$) \\
            = $1 + len(s \bullet t)$ = $1 + len(s) + len(t)$ \qquad \qquad \qquad \qquad \qquad (Por la hipótesis inductiva) \\
            = $(1 + len(s)) + len(t)$ = $len(\<a,s\>) + len(t)$ \\
    
    \end{exercise} 

    % Ejercicio 2.5
    \begin{exercise}
        Utiliza inducción estructural para demostrar
            \[ len(rev(s)) = len(s) \]

        \textbf{Caso Base} $s = \varepsilon$ \\
            $len(rev(s)) = len(rev(\varepsilon)) = len(\varepsilon) = len(s)$.  \qquad \qquad \qquad \qquad  (Por la definición de $rev$) \\\\
            \textbf{Hipótesis Inductiva} $len(rev(s)) = len(s) \ \forall s \in $ A* \\\\
            \textbf{Paso Inductivo} Por demostrar para $s' = \<a, s\> $, \textit{a} $\in$ A y \textit{s} $\in$ A* \\
            $len(rev(\<a, s\> )) = len(rev(s) \bullet \<a,\varepsilon\>)$ \qquad \qquad \qquad \qquad \qquad \ \ (Por la definición de $rev$)\\
            = $ len(rev(s)) + len(\<a,\varepsilon\>)$  \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad (Por la propiedad anterior)\\
            = $len(rev(s)) + 1 + len(\varepsilon)$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad \ \ (Por la definición de len)\\ 
	    = $len(rev(s)) + 1 + 0$\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad  \quad \ \ \ (Por la definición de len)\\ 
            = $ 1 + len(rev(s)) = 1 + len(s)$   \qquad \qquad \qquad \qquad \qquad \qquad \ \ \ (Por la hipótesis inductiva) \\
            = $len(\<a,s\>)$ \qquad \qquad \qquad \quad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad \ \ (Por definición de $len$) 

    \end{exercise}

    % Definición 2.4 Arboles binarios balanceados de altura K y tipo A, Función para contar los nodos de un árbol
    \begin{definition}
        Definimos la estructura de datos árboles binarios de tipo A denotados como Tree A con las siguientes reglas\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}}:

        \begin{enumerate}
            \item $\emptyset$ Tree A.
            \item Si  $t_1$ Tree A y $t_2$ Tree A y $a \in $ A  entonces  $node(a,t_1,t_2)$ Tree A.
            \item Son todos.
        \end{enumerate} 


        % $\text{1) $\emptyset$ es un árbol de tipo A}$ \\
        % $\text{2) Sí } t_1 \text{y } t_2 \text{ son árboles de tipo A y } a \in A \text{ entonces } node(a,t1,t2) \\
        % \text{es un árbol binario de tipo A}$.\\
    \end{definition}

  \begin{definition}
        Definimos la función para obtener la altura de los elementos de Tree A denotada $height(t)$ :: Tree A $\rightarrow$ Int,  como sigue:\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}}:
       \[
            \begin{array}{rcl}
            	height(\emptyset) & = & 0 \\
           	height(node(a,t_1,t_2)) & = & max(h_1,h_2) + 1 \text{ donde } h_1 = height(t_1) \text{ y } h_2 = height(t_2)
         \end{array}
        \]
    \end{definition}
  
    \begin{definition}
        Definimos la función que cuenta el número de nodos de los elementos de Tree A denotada $n_n(t)$ :: Tree A $\rightarrow$ Int,  como\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}}:
        \[
            \begin{array}{rcl}
                 n_n(\emptyset)     &  =  & 0  \\
                 n_n(node(a,t_1,t_2))&  =  &1+ n_n(t_1)+n_n(t_2) 
            \end{array}
        \]

    \end{definition}

    % Ejercicio 2.6
    \begin{exercise}
        Demuestra utilizando inducción estructural que si \textit{t} Tree A con altura \textit{k} entonces $n_n(t) \leq 2^k - 1$ \\\\
        \textbf{Caso Base} $t = \emptyset$, $k=0$\\\\
            $n_n(\emptyset) = 0  \leq 2^0 -1 $ = $1 -1$ = 0.\\\\
        \textbf{Hipótesis Inductiva} $n_n(t) \leq 2^k - 1$,  para todo $t$ Tree A, donde $height(t)=k$. \\\\
        \textbf{Paso Inductivo} Por demostrar $n_n(node(a,t_1,t_2)) \leq 2^{k+1} - 1$ donde $height(node(a,t_1,t_2)) = k + 1$ y $height(t_1) = height(t_2) = k$.\\\\
            $n_n(node(a,t_1,t_2)) = 1 + n_n(t_1) + n_n(t_2)$ \quad \quad \quad \quad \quad \quad \ \ \ \  (Por definición de $n_n(t)$) \\
            $\leq 1 + (2^{k} - 1) + (2^{k} - 1)$ \qquad \qquad \qquad \qquad \qquad \qquad  \ \ (Por la hipótesis inductiva) \\
            $= 1 + 2(2^{k} - 1)$ = $2^{k+1} - 2 + 1$ = $2^{k+1} - 1$\\
    \end{exercise}

% Sección 3: sistemas de transición
\section{Sistemas de transición}
    En el contexto de las ciencias de la computación los sistemas de transición resultan particularmente útiles para obtener cualquier configuración de un programa en cada paso de su ejecución en forma de estados. En particular tendremos dos clases de estados especiales para denotar la configuración inicial y la configuración final. Adicionalmente nos apoyaremos de un conjunto de reglas que nos permiten aplicar instrucciones y operadores para movernos de una configuración a otra\footnote{ Para el enfoque que seguimos en este manual definiremos las reglas de nuestros sistemas de transición como juicios lógicos.}.\\\\
    Obtener todas las configuraciones posibles partiendo de un estado inicial a un estado final nos facilitará hacer el análisis de complejidad en tiempo y en espacio de nuestros programas.\\\\
    Estructuras similares se han estudiado en cursos como autómatas y lenguajes formales\footnote{Conforme al plan de estudios que se imparte desde el 2013 en la Facultad de Ciencias de la Universidad Nacional Autónoma de México con clave de asignatura 1425. } donde adicionalmente se define el alfabeto y se considera la lectura de un carácter para obtener una configuración distinta. En este caso omitiremos estos elementos y nos concentraremos únicamente en los estados y las reglas de transición.
    \begin{exercise}
   
        Supón que se quiere modelar una partida de pimpón donde hay 2 jugadores A y B (el jugador A siempre empieza primero), y un marcador que cuenta el número de puntos de A y B representado como una terna: \[ \text{(jugador en turno, puntuación de A, puntuación de B)} \] 
  
        De tal forma que cada estado indica la información del juego hasta ese punto. \\\\
        Para indicar la transición entre estados utilizamos la notación "$\rightarrow$". Por ejemplo si el jugador B anota, la transición se modela como: \[ (\text{B,X,Y}) \rightarrow (\text{B,X,Y+1}) \]  ya que el jugador que anota un punto vuelve a tirar la pelota en el siguiente turno.\\
        La partida acaba cuando alguno de los dos logra anotar 10 puntos. \\

        En base a la especificación dada anteriormente contesta lo siguiente:
        \begin{enumerate}
            \item Define formalmente el conjunto de estados (indica estados iniciales con la letra  ''I'', finales con la letra  ''F'' y los intermedios con ''$\Gamma$''): 

                \begin{equation}
                    \text{I} = \{(\text{A},0,0)\}\nonumber
                 \end{equation}    

                 \begin{equation}
                    \Gamma = \{(\text{C},\text{X},\text{Y})\} \text{ donde } \text{C} \in \{\text{A},\text{B}\} \text{ y } 0 \leq \text{X},\text{Y} \leq 10\nonumber
                 \end{equation}

                \begin{equation}
                    \text{F} =  \{(\text{C},\text{X},\text{Y})\} \text{ donde } \text{C} \in \{\text{A},\text{B}\} \text{ y X o Y} = 10\nonumber
                \end{equation}

            \item  Define la función de transición (enlista cuales son los casos y como se comporta la función en cada uno de estos).\\\\
		Definimos la función de transición $f(s) :: \text{I} \cup \Gamma  \rightarrow \Gamma \cup \text{F}$ a partir de los siguientes casos:\\\\
                Sí el jugador A puntúa: 
                \[ f((\text{A},\text{X},\text{Y})) = (\text{A},\text{X}+1,\text{Y}) \]
                Sí el jugador B puntúa: 
                \[f((\text{B},\text{X},\text{Y})) = (\text{B},\text{X},\text{Y}+1)\]
                Sí el jugador A no puntúa: 
                \[ f((\text{A},\text{X},\text{Y})) = (\text{B},\text{X},\text{Y}) \]
                Sí el jugador B no puntúa: 
                \[ f((\text{B},\text{X},\text{Y})) = (\text{A},\text{X},\text{Y}) \]
	     Sí el jugador C $\in \{\text{A},\text{B}\}$ hace un saque: 
                \[ f((\text{C},\text{X},\text{Y})) = (\text{C},\text{X},\text{Y}) \]
	\item Define mediante reglas de inferencia la implementación para la función de transición para cada uno de los casos descritos en el ejercicio anterior.
                \[
                \scalemath{0.81}{
                    \begin{array}{lcl}    
                        \inference{(\text{A},\text{X},\text{Y})\ \text{ I} \cup \Gamma, & (\text{B},\text{X},\text{Y})\ \text{ I} \cup \Gamma}{(\text{A},\text{X},\text{Y})\rightarrow(\text{B},\text{X},\text{Y})\  \text{ I} \cup \Gamma}[$(\text{A})$] \qquad 
                        \inference{(\text{B},\text{X},\text{Y})\ \text{ I} \cup \Gamma,& (\text{A},\text{X},\text{Y})\ \text{ I} \cup \Gamma}{(\text{B},\text{X},\text{Y})\rightarrow(\text{A},\text{X},\text{Y})\  \text{ I} \cup \Gamma}[$(\text{B})$] 
                    \end{array}
                }
                \]
\bigskip
		\[
                \scalemath{0.75}{
                    \begin{array}{lcl}    
                        \inference{(\text{A},\text{X},\text{Y})\ \text{ I} \cup \Gamma & (\text{A},\text{X}+1,\text{Y})\text{ } \Gamma \cup \text{F} }{(\text{A},\text{X},\text{Y})\rightarrow(\text{A},\text{X}+1,\text{Y})\ \text{ } \Gamma \cup \text{F}}[$(\text{A}+)$] \qquad 
                        \inference{(\text{B},\text{X},\text{Y})\ \text{ I} \cup \Gamma ,& (\text{B},\text{X},\text{Y}+1)\ \text{ } \Gamma \cup \text{F}}{(\text{B},\text{X},\text{Y})\rightarrow(\text{B},\text{X},\text{Y}+1)\  \text{ } \Gamma \cup \text{F}}[$(\text{B}+)$] 
                    \end{array}
                }
                \] 
                \bigskip
                \[
                \scalemath{0.81}{
                    \begin{array}{lcl}    
                        \inference{(\text{C},\text{X},\text{Y})\  \Gamma}{(\text{C},\text{X},\text{Y})\rightarrow(\text{C},\text{X},\text{Y})\ \Gamma}[$(saque)$] 
   
                    \end{array}
                }
                \] 
            \item Muestra una ejecución donde gane el jugador B especificando cada estado desde el inicial hasta el final: 
                \begin{center}
                    $ (\text{A},0,0) \rightarrow (\text{A},1,0) \rightarrow (\text{A},1,0) \rightarrow (\text{B},1,1) \rightarrow (\text{B},1,1) \rightarrow$ \\
                    $ (\text{B},1,2) \rightarrow (\text{B},1,2) \rightarrow (\text{B},1,3) \rightarrow (\text{B},1,3) \rightarrow (\text{B},1,4) \rightarrow$ \\
                    $ (\text{B},1,4) \rightarrow (\text{B},1,5) \rightarrow (\text{B},1,5) \rightarrow (\text{A},2,5) \rightarrow (\text{A},2,5) \rightarrow$ \\
                    $ (\text{B},2,6) \rightarrow (\text{B},2,6) \rightarrow (\text{B},2,7) \rightarrow (\text{B},2,7) \rightarrow (\text{A},3,7) \rightarrow$ \\
                    $ (\text{A},3,7) \rightarrow (\text{A},4,7) \rightarrow (\text{A},4,7) \rightarrow (\text{B},4,8) \rightarrow (\text{B},4,8) \rightarrow $\\
                    $ (\text{A},5,8) \rightarrow (\text{A},5,8) \rightarrow (\text{B},5,9) \rightarrow (\text{B},5,9) \rightarrow (\text{B},5,10) $
                \end{center}
                En donde la secuencia se puede interpretar como: \\\\
                 ''El jugador A hizo el saque inicial y el marcador muestra A con 0 y B con 0 puntos '', después  ''El jugador A anotó y el marcador muestra A con 1 punto y B con 0 puntos '', después  ''El jugador A hizo el saque inicial pues anotó en el turno anterior y el marcador muestra A con 1 punto y B con 0 puntos '', después  ''El jugador B anotó y el marcador muestra A con 1  punto y B con 1 punto '', después  ''El jugador B hizo el saque inicial pues anotó en el turno anterior y el marcador muestra A con 1  punto y B con 1 punto '', después  ''El jugador B anotó y el marcador muestra A con 1  punto y B con 2 puntos... ''         
        \end{enumerate}

    \end{exercise}

% Sección Ejercicios al lector
\section{Ejercicios para el lector}
    
    %    Ejercicio 4.3
    \begin{exercise}
        Escribe el árbol de derivación para la siguiente cadena utilizando la definición 2.1 para el tipo de dato A*: 
        \[ \<1,\<0,\varepsilon\>\> \]
    \end{exercise}

    %    Ejercicio 4.4
    \begin{exercise}
        Escribe el árbol de derivación para la siguiente cadena utilizando la definición 2.1 para el tipo de dato A*: 
        \[\<1,\<1,\<1\<0,\varepsilon\>\>\>\>\]
    \end{exercise}

    %    Ejercicio 4.5
    \begin{exercise}
        Escribe el árbol de derivación para la siguiente cadena utilizando la definición 2.1 para el tipo de dato A*: 
        \[ \<1,\<0,\<0,\<0,\<0,\<1,\varepsilon\>\>\>\>\>\> \]
    \end{exercise}

    %    definición 4.1: definición de la función map
    \begin{definition}
        Definimos la función \textit{map} :: (A $\rightarrow$ A) $\rightarrow$ A* $\rightarrow$ A*  \\que recibe una función \textit{f} y una cadena \textit{s} de la siguiente forma\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}}: 
        \[
            \begin{array}{rcl}
                \textit{map } f\ \varepsilon& = & \varepsilon \\
                \textit{map } f\ \<a, s\>&   = & \<\textit{f}\text{ a}, \textit{map}\ f\ s \>
            \end{array}
        \]
    \end{definition}

    %    Ejercicio 4.1
    \begin{exercise}
        Demuestra utilizando la inducción estructural sobre el tipo de dato A* que:
        \[\textit{len} (\textit{map }\ f\ \<a,s\> ) =  \textit{len}(\<a,s\>)\]
    \end{exercise}

    %    Ejercicio 4.2
    \begin{exercise}
        Demuestra utilizando la inducción estructural sobre el tipo de dato A* que:
        \[\textit{map } f\ \<a,s\> \bullet \<b,t\> = \textit{map } f\  \<a,s\> \bullet \textit{map } f\  \<b,t\>\]
    \end{exercise}

	\begin{definition}
Un árbol binario completo es un tipo de árbol binario en el que todos los niveles, excepto posiblemente el último, están completamente llenos, y todos los nodos están lo más a la izquierda posible\footnote{Definición extraída de: \hyperlink{68}{[68]}}.
	\end{definition}

    %    Ejercicio 4.6
    \begin{exercise}
        Demuestra utilizando la inducción estructural sobre el tipo de dato Tree A que se cumple la siguiente afirmación:\\\\
        Sea \textit{t} Tree A, tal que $t$ es completo, entonces:
        \[ height(t) = floor(log_{2}(n_n(t)))\]
    \end{exercise}

    %    Ejercicio 4.7
    \begin{exercise}
Demuestra utilizando la inducción estructural sobre el tipo de dato Tree A que se cumple la siguiente afirmación:\\\\
        Sea \textit{t} Tree A, tal que $t$ es completo, entonces:
        \[   n_i(t) = \frac{n_n(t) - 1}{2} \] donde $n_i(t)$ es el número de nodos internos en un árbol y $n_n(t)$ es el número de total de nodos.
    \end{exercise}

    %    Ejercicio 4.8
    \begin{exercise}
        De acuerdo con el sistema de transición definido en el ejercicio 3.1, contesta lo siguiente: 
	\begin{item}
		\item ¿El jugador B puede iniciar una partida?
		\item ¿Los jugadores A y B pueden empatar?
		\item ¿El marcador puede subir mas allá de los 10 puntos para algún jugador?
		\item ¿El marcador puede bajar mas allá de los 0 puntos para algún jugador?
		\item ¿Es posible moverse de un estado intermedio a un estado final?
		\item ¿Es posible moverse de un estado inicial a un estado final?\\\\
 	\end{item}	
        Justifica tus respuestas
    \end{exercise}

    %    Ejercicio 4.9
    \begin{exercise}
        De acuerdo con el sistema de transición definido en el ejercicio 3.1 muestra una ejecución en la que el jugador A gane.
    \end{exercise}

    %Ejercicio 4.10
    \begin{exercise}
        Suponga que se necesita definir un lenguaje que permita controlar los movimientos de un robot. El robot se mueve sobre una cuadrícula siguiendo las instrucciones especificadas por el programa. \\\\
        Al inicio el robot se encuentra en la coordenada (0,0) y viendo hacia el norte. El programa consiste en una secuencia posiblemente 
        vacía de los comandos \texttt{move} y \texttt{turn} separados por punto y coma (';'), donde cada comando tiene el siguiente funcionamiento\footnote{ejercicio extraído de \hyperlink{107}{[107]}}:\\
    
        \begin{itemize}
            \item \texttt{turn} hace que el robot de un giro de 90 grados en el sentido de las manecillas del reloj.
            \item \texttt{move} provoca que el robot avance una casilla en la dirección hacía la que está viendo.\\
        \end{itemize}

        Donde un ejemplo de un programa válido puede ser el siguiente:
        \[   \texttt{move};\texttt{turn};\texttt{move};\texttt{turn};\texttt{turn};\texttt{turn};\texttt{move} \]
        Al final de la ejecución programa el robot termina en la casilla (2,1). La primera entrada de la coordenada
        indica la posición vertical mientras que la segunda es la posición horizontal.\\\\

        Con la especificación discutida anteriormente contesta los siguientes puntos:\\

        \begin{enumerate}
            \item Determina el conjunto de estados. 
            \item Identifica los estados iniciales y finales del sistema de transición.
            \item Define la función de transición $\rightarrow_R$ que indique como se debe transitar entre los estados del sistema.
            \item Muestra paso a paso la ejecución del programa:
                  \[  \texttt{move};\texttt{turn};\texttt{move};\texttt{turn};\texttt{turn};\texttt{turn};\texttt{move} \]
                  Utilizando la relación $\rightarrow_R$ y partiendo del estado inicial.
         \end{enumerate}

    \end{exercise}


    Para finalizar esta sección vamos a revisar dos ejercicios prácticos que implementaremos en \texttt{Haskell}. Estos ejercicios combinan las definiciones de las funciones que hemos estudiado hasta este punto para listas y que ejemplifican las propiedades recursivas de estas estructuras en un lenguaje de programación funcional\footnote{Los ejercicios 4.11 y 4.12 fueron extraídos de \hyperlink{75}{[75]}.}.


    \begin{exercise}
        La validación del número de una tarjeta de crédito se hace implementando un algoritmo \texttt{checkSum} obteniendo información de los dígitos que la componen. Para eso implementaremos nuestro propio validador de tarjetas de crédito como sigue:\\
    
        Los dígitos que están una posición impar (empezando por el índice 0 de izquierda a derecha) se deben duplicar. \\\\
        Posteriormente se suman todos los dígitos de los números que componen la tarjeta (aquellos números que fueron duplicados deben de ser sumados junto con el resto que no se modificaron).\\\\
        Por último se aplica el módulo 10 al resultado de la suma, si el resultado es diferente de 0 entonces la tarjeta es inválida, en caso contrario es válida.\\
        \begin{enumerate} 
           \item  Implementa la función {\tt getDigits :: Int ->\ [Int]} \\\\
                  Por ejemplo, la tarjeta \[1348\ 1548\ 9998\ 6535\] dará como resultado la lista: \texttt{[1,3,4,8,1,5,4,8,9,9,9,8,6,5,3,5]} \\
                  (asumimos que la entrada son solo los dígitos de la tarjeta sin separación).\\
          % \item  Implementa la función \texttt{reverseDigits ::  [Int] ->\ [Int]} \\\\
            %      Esta función obtiene la reversa de la lista de los dígitos obtenidos en el paso anterior.\\
           \item  Implementa la función \texttt{duplicateOddPositionDigits ::  [Int] ->\ [Int]} \\\\
                  Por ejemplo: la lista \texttt{[1,3,4,8,1,5,4,8,9,9,9,8,6,5,3,5]} solo duplicará los números que estén en una posición impar obteniendo como resultado: \texttt{[1,6,4,16,1,10,4,16,9,18,9,16,6,10,3,10]}. \\
           \item  Implementa la función \texttt{toDigits :: Int ->\ [Int]}\\\\
                  El objetivo de la implementación de esta función es el de obtener los dígitos de los números mayores o iguales a 10, de tal forma que si tenemos como parámetro de entrada para esta función a la lista \texttt{[1,6,4,16,1,10,4,16,9,18,9,16,6,10,3,10]} obtengamos la siguiente como resultado \texttt{[1,6,4,1,6,1,0,4,1,6,9,1,8,9,1,6,1,0,3,1,0]} \\
           \item  Implementa la función \texttt{sumDigitsInList :: [Int] ->\ Int} \\\\
                  Esta función simplemente suma los dígitos contenidos en la lista (puedes utilizar la función sum provista por \texttt{GHCi}).\\
           \item  Implementa la función \texttt{checkSumCreditCard :: Int ->\ Bool}\\\\
                  Recuerda que el criterio de validez es que la suma de los dígitos filtrados de la tarjeta módulo 10 sea igual a 0.
                    
        \end{enumerate}    
    \end{exercise}

    \begin{exercise}
        Las torres de Hanoi son un un rompecabezas clásico cuya solución puede ser escrita de forma recursiva. Los discos de diferentes tamaños se apilan del más grande al más pequeño y el objetivo es moverlos del pivote inicial al pivote final, dónde pivotes = discos = n.\\\\
 Las reglas son  las siguientes: 
        \begin{enumerate}
            \item Ningún disco puede estar encima de un disco mas pequeño. 
            \item Por cada movimiento, solo es válido el desplazamiento de un disco hacía otro pivote.\\
        \end{enumerate}

        Se definen los siguientes tipos para implementar la solución al problema de la siguiente forma: 
        \begin{center}
            \begin{verbatim}
                          type Peg  = String
                          type move = (Peg, Peg)
            \end{verbatim}
        \end{center}
	\texttt{Peg} designa el nombre del pivote y \texttt{move} es una tupla ($origen$, $destino$) que modela el moviento del disco que está en el tope de la pila del pivote origen al pivote destino. \\

        Implementa la función \texttt{Hanoi :: Int} $\rightarrow$ \texttt{[Peg]} $\rightarrow$ \texttt{[move]}
        Que dada el número de discos y una lista con el nombre de los pivotes regrese una lista con los movimientos para mover los discos desde el pivote de la extrema izquierda hasta el pivote de la extrema derecha, por ejemplo con n = 3: 
        \begin{center}
            \texttt{Hanoi 3  [''A'' ''B'' ''C''] =  [(''A'',''C''),(''A'',''B''),(''C'',''B''),}
	 \texttt{(''A'',''C''),(''B'',''A''),(''B'',''C''),(''A'',''C'')]}
        \end{center}
		

    \end{exercise}  
	\begin{figure}
    		\centerline{\includegraphics[scale=.3]{assets/Hanoi.jpeg}}       
	\end{figure}


%https://comp.anu.edu.au/courses/comp2600/Lectures/11ListInduction.pdf
%https://courses.engr.illinois.edu/cs173/fa2010/Lectures/trees.pdf
%https://math.stackexchange.com/questions/2615653/using-structural-induction-to-prove-a-property-of-full-binary-trees