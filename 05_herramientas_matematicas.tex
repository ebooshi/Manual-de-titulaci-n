
%    Segundo capítulo: Herramientas Matemáticas.
%    Ejercicios por Barón M. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 21/10/22
%    Concluido el 25/10/22

%Gatito Constructor
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=.22]{assets/02_gatito_herramientas_matematicas.jpg}}
    \label{fig 1. Mapa para clasificar los lenguajes de programación.}        
\end{figure}

Para estudiar a los lenguajes de programación es necesario definir una estructura que nos permita capturar su escencia matemática y nos proporcione un mecanismo para demostrar características y propiedades asociadas a estos. \\\\
Una manera de definir formalmente un lenguaje de programación es mediante el uso de juicios lógicos\footnote{En lógica el equivalente a un juicio lógico son los predicados que denominan una característica que se cumple en una proposición.} para definir propiedades, pertenencia de los elementos de nuestra estructura a un conjunto, relación entre diferentes elementos de una misma estructura, etc. Que junto con la aplicación de reglas de inferencia nos permitirán dar una definición inductiva de las estructuras que vamos a construir en el resto del manual\footnote{Para las personas que poseen una madurez matemática superior a aquella que la que un estudiante de cuarto semestre de la Facultad de Ciencias pudiera tener se recomienda encarecidamente iniciar el estudio de este manual en el \hyperref[sec:sintax]{capítulo 3: Sintáxis}. Los temas recomendados para omitir los primeros dos capítulos del manual son: estructuras discretas, juicios lógicos, reglas inductivas, reglas de inferencia e inducción estructural. }. \\
\subsection*{Objetivo}
Estudiar las estructuras matemáticas que utilizaremos para familiarizarnos con el concepto de inducción estructural. En particular centraremos nuestra atención a estructuras recursivas como listas de tipo A y árboles binarios balanceados de tipo A\footnote{donde A es un conjunto o una colección de elementos.} junto con las reglas de inferencia que las generan para ilustrar la naturaleza recursiva que estas poseen.\\\\
Este tipo de mecanismos es particularmente útil para ilustrar las propiedades de los lenguajes que definiremos a lo largo de los capítulos de este manual.

\subsection*{Planteamiento}
En este capítulo exploraremos diferentes estructuras empezando por los juicios lógicos que consituyen las entidades fundamentales sobre las cuales iniciaremos el estudio de los lenguajes.
También estudiaremos brevemente estructuras inductivas como cadenas y listas para enunciar el principio de inducción que nos permite demostrar propiedades sobre dichas estructuras. Por último estudiaremos un sistema de transición para modelar los estados y reglas de evaluación de la instancia de un juego.

%    Sección 1: Juicios lógicos.
\section{Juicios lógicos}

    Una parte fundamental del razonamiento matemático es la capacidad de determinar si una afirmación es verdadera o falsa basado en la información que poseemos sobre los elementos que son mencionados en dicha afirmación. \\\\
    Para poder aplicar un juicio sobre algún elemento, objeto o entidad para determinar su veracidad primero debemos definir dichos elementos. A continuación vamos a introducir los conceptos necesarios para poder formalizar esta noción y como aplicarla. Esto será de utilidad para definir características, reglas de construcción y reglas de evaluación en los lenguajes de programación y modelos de computo que discutiremos a lo largo del manual.\\

    \bigskip

    % Ejercicio 1.1
    \begin{exercise}
	¿Qué es un objeto? \\  \\
	   ''En el lenguaje habitual de las matemáticas, un objeto es cualquier cosa que ha sido (o podría ser) definida formalmente y con la que se pueden realizar razonamientos deductivos y pruebas matemáticas. ''\footnote{Definición extraída de \hyperlink{58}{[58]}, formulada de  \hyperlink{59}{[59]} y \hyperlink{60}{[60]}}
    \end{exercise}

    % Ejercicio 1.2
    \begin{exercise}
	¿Qué es un juicio? \\ \\
         ''En lógica matemática, un juicio es una afirmación o enunciación en un metalenguaje de una característica o propiedad sobre un objecto o elemento de un dominio. ''\footnote{Definición extraída de \hyperlink{61}{[61]}, formulada de \hyperlink{62}{[62]}.}
    \end{exercise} 

    % Ejercicio 1.3
    \begin{exercise}
	Proporciona un listado de juicios sobre objetos matemáticos (Puedes suponer definidos con anterioridad elementos como $\mathbb{N}$, $\mathbb{Q}$, Bool, \textit{String}, funciones, relaciones de orden, operadores arítmeticos, etc).
	\begin{center}
		\begin{tabular}{rl}
			 ''Hola Mundo '' \textbf{$String$} & La cadena  ''Hola Mundo '' es de tipo $String$.  \\
			L \textbf{$NP$} & El lenguaje L es $NP$. \\
			\textit{a} $\textgreater$ \textit{b} & el número $a$ es más grande que el número $b$. \\
			A $|$ B  & El evento A es independiente al evento B. \\
			\textit{True} Bool  & La constante \textit{True} es de tipo Bool.  \\
			h = \( g \circ f \) & la función $h$ es la composición de la función $g$ con la función $f$.\\
			3.1416... $\mathbb{I}$ & El número 3.1416... es  irracional \\
			0 $\mathbb{N}$  & 0 es un Natural. \\
			S(0) impar & El sucesor de 0 es impar.\\
			$\frac{p}{q}$  $\mathbb{Q}$  & La fracción $\frac{p}{q}$ es un racional.\\
		\end{tabular}
	\end{center}
    \end{exercise}

%    Sección 2: Reglas de Inferencia, Inducción estructural.
\section{Reglas de inferencia}

    Las reglas de inferencia\footnote{En esta manual utilizaremos el término  ''regla de inferencia '' o  ''juicio lógico '' de forma indistinta.} son una representación de la aplicación de un juicio de la forma:  ''Si las premisas $p_1,p_2,\ ...\ p_n$ son verdaderas, entonces $c$ es verdadero ''. Visualmente esto se denota como:
    \[
        \inference{p_1,p_2,\ ...\ p_n}{\textit{c}}
    \]
    Podemos observar que las reglas de inferencia están compuestas por dos secciones: una sección superior y una inferior. 
    La sección superior es en donde se agrupan las condiciones necesarias para que la regla pueda ser aplicada (a los elementos enlistados en esta parte se les conoce como premisas o hipótesis), cada una de estas están separadas por una coma (',') y todas deben de cumplirse\footnote{El signo de puntuación (',') se puede interpretar como el operador $\wedge$ donde cada hipótesis es un argumento de dicho operador.}. \\\\
    La sección inferior de una regla de inferencia enlista el resultado de la aplicación de la regla a las premisas. Ocasionalmente la regla tendrá un nombre que ayuda a identificar cuál de ellas es aplicada cuando se trabaja con derivaciones y razonamientos\footnote{Definición formulada de \hyperlink{1}{[1]}, \hyperlink{5}{[5]}, \hyperlink{9}{[9]}, \hyperlink{63}{[63]}, \hyperlink{64}{[64]} y \hyperlink{91}{[91]}.}. En esta sección de la regla puede haber uno o más elementos resultados de la aplicación pero no puede ser vacía. \\\\
    Los axiomas son las reglas de inferencia que carecen de hipótesis dado que siempre serán verdad y no es necesario suponer nada para concluirlas.\\\\
    Tomemos como ejemplo la definición de las cadenas binarias de tipo A (denominaremos a este tipo de dato como A*) para ilustrar las reglas de inferencia y sus partes anteriormente discutidas.

    \bigskip

    % Definición: Cadenas Binarias y función de concatenación.
    \begin{definition}
        Sea $\text{A} = \{ 0,1 \}$ un conjunto. Definimos el tipo de dato recursivo $\text{A}^*$ (cadenas binarias de tipo A)\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]} y \hyperlink{69}{[69]}} como sigue: \\
            \[
                \begin{array}{lcl}    
                    \inference{}{\varepsilon \in \text{A}^*}[\textit{(eps)}] \qquad 
                    \inference{a \in \text{A}, s \in \text{A}^*}{\<a, s\> \in \text{A}^*}[\textit{(tup)}]
                \end{array}
            \] 


            La regla \textit{eps} se lee como:  ''la cadena vacía es una cadena binaria de tipo A '', Nótese que esta regla es un axioma dado que carece de premisas. \\\\
            La regla \textit{tup} se lee como:  ''si \textit{a} es de tipo A y \textit{s} es una cadena binaria de tipo A, entonces la construcción de una tupla con cabeza \textit{a} y cola \textit{s} es una cadena binaria de tipo A. ''\\\\
            Por ejemplo, la cadena 10101 se representa por la 5-tupla $\<1,\<0,\<1,\<0,\<1. \epsilon \>\>\>\>\>$ 
    \end{definition}

    \bigskip

\section{Estructuras recursivas e inducción estructural}

    Ahora discutamos un tipo de estructuras particulares que se relacionan de forma íntima con los conceptos anteriormente planteados; las estructuras recursivas\footnote{Definición formulada a partir de \hyperlink{91}{[91]}, \hyperlink{92}{[92]} y \hyperlink{93}{[93]}}. Estas se generan a partir de dos casos:
    \begin{itemize}
 
        \item La estructura está compuesta por el elemento más primitivo que puede formar parte de esta.
        Muchas veces este elemento constituye la clausula de escape para la recursión inducida por la definición y constituiría un axioma en su representación como regla de inferencia.
        \item La estructura está compuesta por una llamada a la función constructora con un elemento nuevo y la estructura misma que se desea definir como argumentos. 
    \end{itemize}


    En el caso de la lista de tipo de dato A*, el elemento más primitivo que pertenece a esta estructura es la cadena vacía (denotada como $\varepsilon$) o bien una tupla con cabeza \textit{a} $\in $ A y cola de tipo A*.\\\\
    Este principio se aplica tanto para definir la estructura recursiva como para las funciones que se quieran aplicar sobre la misma\footnote{Información obtenida de \hyperlink{94}{[94]} y \hyperlink{95}{[95]}}. Para ilustrar este punto definimos la función para concatenar dos elementos de A* de la siguiente forma: 
    \begin{definition}
        Definimos la concatenación de cadenas A* denotada como\\ $\bullet$ ::\ (A* $\rightarrow$\ A*) $\rightarrow$\ A* mediante la siguiente especificación\footnote{Definición formulada a partir de \hyperlink{67}{[67]}, \hyperlink{68}{[68]}}:
        \[
            \begin{array}{rcl}
                \text{Caso base:}   & \varepsilon \bullet t  =   t &  (\textit{eps}) \\
                \text{Constructor:} & \<a,s\> \bullet t  =  \<a,\<s \bullet t\>\> & (\textit{tup})
            \end{array}
        \]
    \end{definition}
    La característica mas importante que las estructuras recursivas poseen es el principio de inducción. Esta propiedad nos permite demostrar que una proposición o propiedad es válida para cualquier elemento de la estructura mediante su aplicación de la siguiente forma:
    \begin{itemize}
        \item Se demuestra la validéz de la proposición para los elementos primitivos.
        \item Posteriormente se asume que la propiedad es válida para cualquier instancia. 
        \item Por último se demuestra la propiedad aplicada para los constructores que generan instancias más grandes aplicando la hipótesis del inciso anterior.
    \end{itemize}

    \bigskip

    % Ejercicio 2.1
    \begin{exercise}
        Utiliza la inducción estructural para demostrar: 
        \[ t \bullet \varepsilon = t\] 
            \textbf{Caso Base} t = $\varepsilon$ \\
            $\varepsilon \bullet \varepsilon$ =  $\varepsilon$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad (Por la definición de $\bullet$) \\
            $\varepsilon$ = $t$. \\\\
            \textbf{Hipótesis Inductiva} $t \bullet \varepsilon = t$  para toda $t \in \text{A}^*$ \\\\
            \textbf{Paso Inductivo} por demostrar $\<a,t\> \bullet \varepsilon = \<a,t\>$ para toda $a \in \text{A}$ y $t \in \text{A}^*$ \\
            $\<a,t\> \bullet \varepsilon$ = $\<a, \<t \bullet \varepsilon \> \>$ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad \quad (Por la definición de $\bullet$) \\
            $\<t \bullet \varepsilon \> = t $ \qquad \qquad \qquad \qquad \qquad \quad \qquad \qquad \qquad \qquad \qquad (Por la hipótesis inductiva) \\
            $\<a,t\> \bullet \varepsilon = \<a, \<t \bullet \varepsilon \> \> = \<a, t\>$ \\ 
    \end{exercise}

    \bigskip

    % Ejercicio 2.2
    \begin{exercise}
        utiliza las reglas (\textit{eps}) y (\textit{tup}) para derivar las cadenas: 
        \[
             \<1,\<0,\<0,\varepsilon\>\>\>, \qquad
             \<1,\<0,\<0\<1,\varepsilon\>\>\>\> \qquad y \qquad
             \<1,\<1,\<1,\<0,\<1,\<0,\varepsilon\>\>\>\>\>\>
        \] 

        \bigskip
        \bigskip

        \scalemath{0.9}{
            \begin{array}{cc}
                \inference{\inference{}{1 \in \text{A}}[(\textit{ax})] \inference{\inference{}{0 \in \text{A}}[(\textit{ax})]& \inference{\inference{}{0 \in \text{A}}[(\textit{ax})]& \inference{}{\varepsilon \in \text{A}^*}[(\textit{eps})]}{\<0, \varepsilon \> \in \text{A}^*}[(\textit{tup})]}{\<0,\<0,\varepsilon\>\> \in \text{A}^*}[(\textit{tup})]}{\<1,\<0,\<0,\varepsilon\>\>\> \in \text{A}^*}[(\textit{tup})]
            \end{array}
        }

