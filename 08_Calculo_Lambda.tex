%    Quinto Capítulo capítulo: Cálclo Lambda.
%    Ejercicios por Barón L. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 18/1/23
%    Concluido el 2/27/23

%Gatito lambda
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=0.20]{assets/05_gatito_lambda.jpg}}       
\end{figure}


%Introducción
Cuando pensamos en el nacimiento de las computadoras podemos inmediatamente asociarlo con las máquinas de Turing, un sistema de transición que se ha estudiado con anterioridad en materias como autómatas y lenguajes formales\footnote{Conforme al plan de estudios que se imparte desde el 2013 en la Facultad de Ciencias de la Universidad Nacional Autónoma de México con clave de asignatura 1425. } siendo el más reconocido cuando se habla de modelos de cómputo y la definición de conceptos como: computabilidad, algoritmo o complejidad. Términos apenas formalizados en 1936.\\\\
En este curso estudiaremos un modelo equivalente de cómputo, es aquí donde Alonzo Church nos introduce en 1928 a su aproximación de un sistema formal basado en el concepto de ''función'' con las primitivas de ''abstracción'' y ''aplicación'' que fungiría como fundamento lógico para sustituir el la teoría de conjuntos de Zermelo-Fraenkel y la teoría de tipos de Russell. Este sistema fue demostrado como inconsistente por sus dos alumnos Stephen Kleene y Barkley Russell pero no todo sería desechado, conservando la parte del manejo de funciones particularmente rica, consistente y sorprendentemente equivalente al modelo de Alan Turing, a este modelo se le conoce como Cálculo Lambda\footnote{Extraído de  \hyperlink{108}{[108]}}.\\


\subsubsection{Objetivo}
Revisar la composición del Cálculo Lambda mediante el estudio de la sintáxis, semántica operacional y la representación de tipos primitivos en este modelo de cómputo, así como las propiedades inherentes a la semántica del cálculo junto con los sistemas de recursión para la evaluación de $\lambda$-expresiones. \\ 

\subsubsection{Planteamiento}
En este capítulo se revisará la sintáxis concreta del Cálculo Lámbda para generar $\lambda$-expresiones junto con
la semántica operacional del cálculo, basándonos en la operación de sustitución sintáctica ([variable := valor]) conocida como $\beta$-reducción.\\\\
También se abordará la definición de los booleanos junto con los operadores lógicos, estructuras de datos (tuplas, proyecciones, listas) y los numerales de Chruch con operadores aritméticos mismos que se espera el lector pueda manipular, razonar y resolver en la sección de ejercicios. \\\\
Finalmente se introducirá el sistema de recursión para el Cálculo Lambda con los operadores de punto fijo.


\section{Sintáxis del Cálculo Lambda}
    El cálculo lambda es un modelo simple, su sintáxis comprende sólo tres categorías de términos\footnote{Definición extraída de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y \hyperlink{110}{[110]}}:
    \begin{itemize}
        \item Variables: Los elementos de esta categoría pertenecen a un conjunto finito de letras mínusculas, generalmente las últimas del alfabeto (w, x, y, z) y son las expresiones lambda más simples.\\
        \item Abstracciones: Esta categoría engloba los términos que definen a las funciones anónimas, compuestas por tres elementos: el primero es la letra griega $\lambda$, el segundo es la variable que estará ligada en el cuerpo de la expresión y por último el cuerpo mismo de la función denotado como $e$, estas se representan de la forma $\lambda x.e$.\\
        \item Aplicación: Esta categoría engloba a las expresiones que representan la aplicación de un argumento a una función. estas son representadas como $e_1\,e_2$ y su evaluación será la sustitución sintáctica ([:=]).
    \end{itemize}

    \begin{definition}[Sintaxis concreta del Cálculo Lambda] Definimos el juicio $l \; \lambda$ que indica que $l$ es una expresión válida en el Cálculo Lambda. A estas expresiones las denominaremos  $\lambda-$expresiones\footnote{Definición extraída de \hyperlink{5}{[5]},  \hyperlink{12}{[12]}, \hyperlink{108}{[108]}, \hyperlink{109}{[109]}}.
    
        \[
            \begin{array}{ccccc}
                \inference{x\;{\sf var}}{x\;\lambda}[$var$]&\quad&
                \inference{x\;{\sf var}&e\;\lambda}{\lambda x.e\;\lambda}[$abs$]&\quad&
                \inference{e_1\;\lambda&e_2\;\lambda}{e_1\,e_2\;\lambda}[$app$]
            \end{array}
        \]
    \end{definition}

\bigskip

    \begin{exercise}
        Para las siguientes $\lambda-$expresiones anota a la derecha a que categoría de la sintáxis del Cálculo Lambda corresponde dicho término.
       \begin{center}
          \begin{tabular}{ c c }

             $x$ 			  	 	  & \text{variable} \\ 
             $y$		 	 	 	  & \text{variable}  \\
             $\lambda x.x$	  		  & \text{función anónima} \\
             $\lambda x.y$   	  		  & \text{función anónima}  \\
             ($\lambda x.x)v$  	    	  & \text{aplicación} \\
             ($\lambda x.x)v'$	 	 	  & \text{aplicación} \\
             $\lambda x.\lambda y.xy$           & \text{función anónima}\\
             $x(\lambda x.y)$ 			  & \text{aplicación}\\
             $(\lambda x.x)(\lambda y.y)$     &  \text{aplicación}	
 
        \end{tabular}
      \end{center}
    \end{exercise}

    En el ejemplo anterior, la tercer $\lambda-$expresión corresponde a la función identidad que regresa el argumento que es pasado como parámetro. La cuarta $\lambda-$expresión corresponde a la función constante que siempre regresa el mismo valor sin importar el parámetro que recibe. La sétima $\lambda-$expresión es la ilustración de como se puede anidar dos funciones anónimas para construir una sola de dos parámetros \footnote{A este proceso se le conoce como currificación en honor a Haskell Curry y nos permite anidar tantas funciones como parámetros necesitemos, este tema será revisado a detalle más adelante en este capítulo}. 

\section{$\alpha$-equivalencia en el Cálculo Lambda}

    En el Cálculo Lambda se tiene un constructor similar al operador \textsf{let} que tiene una variable ligada, un alcance asociado a ella y con esto el concepto de $\alpha$-equivalencia fue introducido para expresiones que difieren a lo más en el nombrado de sus variables ligadas. 
    \begin{definition}[$\alpha$-equivalencia en el Cálculo Lambda]  Dos $\lambda-$expresiones $e_1$ y $e_2$ son $\alpha$-equivalentes si y sólo si solo difieren a lo mas en el nombre de las variables ligadas\footnote{Definición extraída de  \hyperlink{5}{[5]},  y  \hyperlink{12}{[12]}}. Esto es denotado como: $$e_1 \equiv_{\alpha} e_2 $$

     Por ejemplo, las expresiones:
    \[
        \begin{array}{ccc}
        \lambda x.x &\quad& \lambda z.z
        \end{array}
    \]
    \noindent
    son $\alpha$-equivalentes y se representa como: $$\lambda x.x\equiv_{\alpha}\lambda z.z$$
    \end{definition}


    \section{Semántica operacional del Cálculo Lambda}
    Cómo se discutió brevemente en la introducción del capítulo, la semántica operacional del Cálculo Lambda está definida por la sustitución sintáctica. 
A la operación de sustituir los términos que concuerden con la variable del operador en la $\lambda-$expresión se le conoce como $\beta$-reducción y se representa con el símbolo $\to_\beta$. 


    \begin{definition}[Semántica operacional del Cálculo Lambda] La semántica operacional está definida por la siguiente regla\footnote{Definición formulada de \hyperlink{5}{[5]},  \hyperlink{12}{[12]},  \hyperlink{108}{[108]} y  \hyperlink{109}{[109]}}: 

    $$(\lambda x.t)\,s \to_\beta t[x:=s] \quad \text{($\beta$-reducción)}$$
    Donde se tienen los siguientes casos según la composición de la $\lambda-$expresión:\\
        \begin{itemize}
        \item $x[x:=r] = r$. 
        \item $y[x:=r] = y$ si $x\neq y$.
        \item $(ts)[x:=r] = t[x:=r]s[x:=r]$.
        \item $(\lambda y.t)[x:=r] = \lambda y.t[x:=r]$ donde $y\notin FV(r)$.
        \end{itemize}
	\bigskip
	Es importante remarcar que la asociatividad de la aplicación de la $\beta$-reducción es hacia la izquierda
    \end{definition}
    
    \begin{exercise}
    Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
    $$e= (\lambda x.z)y$$
    \[ (\lambda x.z)y \rightarrow_\beta  z [x := y]\]
    \[ = z \]
    \end{exercise}

    \begin{exercise}
        Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
        $$e = (\lambda x.x)(\lambda y.yy) z$$
        \[ (\lambda x.x)(\lambda y.yy) z \rightarrow_\beta (x[x:=\lambda y.yy])(z)\]
        \[ = (\lambda y.yy)(z) \rightarrow_\beta yy[y:=z]\]
        \[ =  y[y:=z]y[y:=z] = zz\]
       \[= zz \]
    \end{exercise}

    \begin{exercise}
        Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
        $$e= (\lambda x.\lambda y.xy)(\lambda z.z)(w)$$
        \[(\lambda x.\lambda y.xy)(\lambda z.z)(w) \rightarrow_\beta (\lambda y.xy[x := \lambda z.z])(w) \]
        \[ =  (\lambda y.x[x := \lambda z.z]y[x := \lambda z.z])(w) = (\lambda y.(\lambda z.z)y)(w) \]
        \[ (\lambda y.(\lambda z.z)y)(w) \rightarrow_\beta (\lambda y.z[z := y])(w) \]
        \[ = (\lambda y.y)(w) \rightarrow_\beta y[y := w] \]
        \[ = w \]
    \end{exercise}

    \section{Definibilidad Lambda}
    En el Cálculo Lambda las funciones son tipos primitivos, estas pueden ser pasadas como argumentos entre sí y generar nuevos elementos válidos para el sistema. Si extrapolamos esta idea para definir entidades primitivas nos encontraremos nombrando funciones para construir los elementos que pertenecen a esta categoría.\\\\
 En el contexto de los lenguajes de programación las entidades primitivas o tipos primitivos nos son proporcionados por la biblioteca estándar del lenguaje (\textsf{int}, \textsf{char}, \textsf{boo}l, etc.). En el Cálculo Lambda estos tipos primitivos serán definidos por funciones anónimas a las que convendremos un nombre para facilitar su representación\footnote{Información consultada de \hyperlink{108}{[108]} y  \hyperlink{109}{[109]}}.

    \subsection{Booleanos y operadores lógicos}
    Las constantes booleanas \textsf{True} y \textsf{False} son entidades opuestas, una es el valor contrario de la otra. Si tratemos de trasladar esta idea a un par de funciones podemos pensar en algo como:
    la función que toma dos argumentos y regresa el primero es el opuesto de la función que toma dos argumentos y regresa el segundo\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{110}{[110]} y  \hyperlink{111}{[111]}}:
    \[
        \lambda x.\lambda y.x
    \]
    \[
        \lambda x.\lambda y.y
    \]
    Estas entidades están haciendo exactamente lo contrario que hace la otra, como las funciones son objetos primitivos en el Cálculo Lambda entonces definiremos este par de elementos como nuestro \textsf{True} y nuestro \textsf{False} respectivamente.

    De esta forma podemos definir funciones que a su vez, construyan la lógica booleana y nos permitan operar instrucciones de control.
    \begin{definition}[Operadores lógicos para el cálculo Lambda] Definimos las constantes booleanas \textsf{True}, \textsf{False}, \textsf{NOT} y \textsf{AND} con las siguientes funciones\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y  \hyperlink{110}{[110]}}:\\

        \begin{itemize}
            \item \textsf{True}  $=_{def}$  $\lambda x.\lambda y.x$ 
            \item \textsf{False}  $=_{def}$   $\lambda x.\lambda y.y$ 
            \item\textsf{NOT}   $=_{def}$   $\lambda z. z  (\textsf{False}) (\textsf{True})$ 
            \item \textsf{AND}  $=_{def}$  $\lambda x.\lambda y. xy (\textsf{False})$ 
	     \item \textsf{If}      $=_{def}$ $\lambda f.\lambda a.\lambda b.fab $
        \end{itemize}
	  \bigskip
	Es importante mencionar que para estas definiciones estamos abusando de la notación al no escribir la definición de las constantes y usar su nombre directamente. Esto es para ahorrar espacio en los desarrollos y estará permitido su uso en los ejercicios posteriores.
    \end{definition}

    Para el operador \textsf{NOT} la lógica de ejecución es aplicar la función identidad al parámetro de entrada, si este es \textsf{True} entonces se regresará el primer argumento, en este caso la constante \textsf{False}: \[ (\lambda x.x (\textsf{False})(\textsf{True}))\textsf{True} \to_\beta^* \textsf{True}(\textsf{False})(\textsf{True}) \to_\beta^* \textsf{False}\] 
	Sí al contrario el parámetro de entrada es \textsf{False} este regresará el segundo argumento, en este caso la constante \textsf{True}: \[ (\lambda x.x (\textsf{False})(\textsf{True}))\textsf{False} \to_\beta^* \textsf{False}(\textsf{False})(\textsf{True}) \to_\beta^* \textsf{True}\]
    En el caso del operador \textsf{AND} la lógica subyacientes es que si el primer parámetro es un \textsf{False} no importa el segundo parámetro que reciba, siempre regresaremos la constante \textsf{False}:
\[ (\lambda x.\lambda y. xy (\textsf{False}))\ \textsf{False}\  w \to_\beta^* \textsf{False}\ w\ (\textsf{False}) \to_\beta^* \textsf{False}  \]
Si recibe como primer parámetro la constante \textsf{True} entonces el resultado será el segundo parámetro:
\[ (\lambda x.\lambda y. xy (\textsf{False}))\ \textsf{True}\  w \to_\beta^* \textsf{True}\ w\ (\textsf{False}) \to_\beta^* w  \]
Notemos que la única forma de evaluar la instrucción \textsf{AND} como \textsf{True} es si se recibe esta constante dos veces.

Para el Cálculo Lambda es desable entonces que los operadores anteriormente definidos, aplicando un número finito de veces la regla de $\to_\beta$ se obtengan los siguientes resultados:
   \begin{center}

        \begin{itemize} \centering
            \item $\mathsf{If}\,\textsf{True}\,e_1\,e_2 \to_\beta^* e_1$ 
            \item $\mathsf{If}\,\textsf{False}\,e_1\,e_2 \to_\beta^* e_2$ 
            \item $\mathsf{NOT}\,\textsf{True}\to_\beta^* \textsf{False}$
            \item $\mathsf{NOT}\,\textsf{False}\to_\beta^* \textsf{True}$
            \item $\mathsf{AND}\,\textsf{False}\,b\to_\beta^* \textsf{False}$
            \item $\mathsf{AND}\,\textsf{True}\,b\to_\beta^* b$
        \end{itemize}
   \end{center} 

     \section{Aritmética del Cálculo Lambda}
        En los lenguajes de programación otro tipo primitivo que es de vital importancia y que se nos es proporcionado por la biblioteca estándar son los números enteros.
        Estas entidades también tienen una representación en el Cálculo Lambda como funciones.\\\\
        La construcción de los números naturales se obtiene al aplicar la función sucesor al cero, de tal forma que no tenemos el número dos, tenemos dos veces la aplicación de la función sucesor al cero: \textit{s(s(0))}, en Cálculo Lambda esta idea se mantiene vigente, los números serán la aplicación anidada de una función a la constante cero. 
     \subsection{Numerales de Church}
        Church introdujó los numerales como la abstracción de dos parámetros ''$s$'' y ''$z$'' en una función anónima, de tal forma que si se desea representar al n-ésimo número este sea formado por la aplicación de $s$ a $z$, n veces\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}:

    \begin{itemize}
        \item $\bar{0}=_{def}\lambda s.\lambda z.z$
        \item $\bar{1}=_{def}\lambda s.\lambda z.sz$
        \item $\bar{2}=_{def}\lambda s.\lambda z.s(sz)$
        \item $\bar{n}=_{def}\lambda s.\lambda z.\underbrace{s(\ldots(s}_{n\;veces} z)\ldots)$
    \end{itemize}

    \subsection{Funciones aritméticas}
	Para los numerales de Church podemos difinir operadores aritméticos similares a los que se utilizan cuando trabajamos con los números enteros, estos operadores nos permitirán computar valores y estarán definidos como una función donde los operandos serán los argumentos de entrada.

    \subsubsection{Función sucesor}
        Comenzamos el estudio de las funciones aritméticas para el Cálculo Lambda definiendo la función sucesor para los numerales de Church, esta función recibe un numeral y construye el sucesor añadiendo un símbolo ''$s$'' al inicio.
        \begin{definition}[Función sucesor para los numerales de Church]\footnote{Definición extraída de \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}
            $$\textsf{suc} =_{def} \lambda n\lambda z\lambda s. s(n \; z \; s)$$
        \end{definition}
     
        \begin{exercise}
            Utiliza la definición de la función sucesor para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{suc } \overline{2}
            \]
            \[
                (\lambda n\lambda z\lambda s.s(n \; z \; s) ) \; \lambda z'\lambda s'.s'(s'z') \rightarrow_\beta 
            \]
		\[
			\lambda z\lambda s.s((\lambda z'\lambda s'.s'(s'z'))\ z \; s) \rightarrow_\beta 
		\]	
            \[
                 \lambda z\lambda s.s(\lambda s'.s'(s'z)\ s) \rightarrow_\beta
            \]
		\[
			\lambda s\lambda s.s(s(sz)) \rightarrow_\beta
		\]
            \[
                = \overline{3}
            \]
        \end{exercise}

        \begin{exercise}
            Utiliza la definición de la función sucesor para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{suc } \overline{5}
            \]
            \[
                (\lambda n\lambda z\lambda s.s(n\ z\ s)) \; \lambda z'\lambda s'.s'(s'(s'(s'(s' \; z')))) \rightarrow_\beta
            \]
		\[
			 \lambda z\lambda s.s((\lambda z'\lambda s'.s'(s'(s'(s'(s'z')))))\ z\ s)  \rightarrow_\beta	
		\]
            \[
                \lambda z\lambda s.s(\lambda s'.s'(s'(s'(s'(s\;z))))\ s) \rightarrow_\beta 
            \]
		\[
			\lambda s\lambda z.s(s(s(s(s(sz)))))
		\]
            \[
                = \overline{6}
            \]
        \end{exercise}

        \subsubsection{IsZero}
        	Este operador está diseñado para regresar \textsf{True} cuando el numeral que recibe como parámetro corresponde al numeral $\overline{0}$. En caso contrario la función regresa \textsf{False} y está definida de la siguiente forma.
        
	\begin{definition}[Función IsZero para numerales de Church]\footnote{Definición extraída de \hyperlink{2}{[2]},  \hyperlink{5}{[5]} y \hyperlink{12}{[12]}}
            $$\textsf{IsZero} =_{def}  \; \lambda m. m\;\textsf{True} \;(\lambda x.\textsf{False})$$
        \end{definition}

        \begin{exercise}
            Utiliza las definición de la función \textsf{IsZero} para evaluar la siguiente $\lambda$-expresión
            \[
                \textsf{IsZero}  \; \overline{2}
            \]
            \[
                (\lambda m. m\;\textsf{True} \;(\lambda x.\textsf{False})) \; \lambda z\lambda s.s(s\;z) \rightarrow_\beta 
            \]
		\[
			(\lambda z\lambda s.s(s\:z)) \; \textsf{True} \; (\lambda x.\textsf{False})  \rightarrow_\beta 
		\]
            \[
                	(\lambda s.s(s\: \textsf{True})) \; (\lambda x.\textsf{False}) \rightarrow_\beta  
            \]
		\[
			(\lambda x.\textsf{false}) \; ((\lambda x.\textsf{false}) \; \textsf{true}))) \rightarrow_\beta  
		\]
            \[
                 \rightarrow_\beta  (\lambda x.\textsf{False}) \; \textsf{false} \rightarrow_\beta 
            \]
		\[
			\textsf{False}
		\]

        \end{exercise}

        \begin{exercise}
            Utiliza las definición de la función \textsf{IsZero} para evaluar la siguiente $\lambda$-expresión
            \[
                \textsf{IsZero} \; \overline{0}
            \]
            \[
                (\lambda m. m\textsf{True} \; (\lambda x.\textsf{False})) \; \lambda z\lambda s.z \rightarrow_\beta 
            \]
		\[
			(\lambda z\lambda s.z) \; \textsf{True} \; (\lambda x.\textsf{False}) \rightarrow_\beta 
		\]
            \[
                   (\lambda s.\textsf{True}) \; \lambda x.\textsf{False} \rightarrow_\beta 
            \]
		\[
			\textsf{True}
		\]
        \end{exercise}
        

    \subsubsection{Suma}
        La suma para los números naturales está definida por inducción sobre el segundo argumento cuyos casos son:
        \begin{enumerate}
            \item m + 0 = m 
            \item m + Sn = S(m + n)
        \end{enumerate}

        Para el cálculo lambda la definición de está función será:
        \begin{definition}[Definición de la suma para los numerales de Church]
            $$sum:  \; \lambda m\lambda n\lambda s\lambda z.n(m \; z \; s) \; s$$
        \end{definition}

        la definición de esta función puede ser entendida en términos de la función suma para los naturales. El argumento m no es afectado por la función en ningún momento, ésto se regleja en la sección interna de nuestra lambda, a saber (m z s). Ésto no altera m, lo simplifica pero mantiene la cantidad de aplicaciones de s, esta simplificación de m es el pimero argumento que va a recibir el numeral n tomándo el lugar de z.\\
        El segundo argumento del numeral n será la s que simplemente reemplazara todas las apariciones de s por s misma.\\\\
        De esta forma lo que al final sucede es que se concatenarán las "s's" de ambos numerales generando así el numeral correspondiente a la suma de las apariciones del carácter "s" en ambos n y m.\\


        \begin{exercise}
            Utiliza la definición de la función sum evaluar la siguiente  $\lambda$-expresión
            \[
                sum  \overline{2} \; \overline{3} 
            \]
            \[
                = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s) \; \lambda z'\lambda s'.s'(s'z') \;\; \lambda z''\lambda s''.s''(s''(s''z'')) \rightarrow_\beta 
            \]
            \[
                (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.s'(s'z')) \; z \; s) \; s) \; \lambda z''\lambda s''.s''(s''(s''z'')) \rightarrow_\beta 
            \]
            \[
                \lambda z\lambda s.((\lambda z''\lambda s''.s''(s''(s''z''))) \; ((\lambda z'\lambda s'.s'(s'z')) \; z \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda z''\lambda s''.s''(s''(s''z'')) \; ((\lambda s'.s'(s'z))  \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda z''\lambda s''.s''(s''(s''z'')) \; (s(sz)) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda s''.s''(s''(s''(s(sz)))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.s(s(s(s(sz)))) = \overline{5}
            \]
        \end{exercise}

        \begin{exercise}
            Utiliza la definición de la función sum evaluar la siguiente  $\lambda$-expresión
            \[
                sum  \overline{4} \; \overline{5} 
            \]
            \[
                = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s) \; \lambda z'\lambda s'.s'(s'(s'(s'z'))) \; \lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \rightarrow_\beta 
            \]
            \[
                (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.s'(s'(s'(s'z'))) \; z \; s) \; s)) \; \lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \rightarrow_\beta 
            \]
            \[
                \lambda z\lambda s(\lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \; (\lambda z'\lambda s'.s'(s'(s'(s'z'))) \; z \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s((\lambda z''\lambda s''.s''(s''(s''(s''(s''z''))))) \; (\lambda s'.s'(s'(s'(s'z)))  \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s(\lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \; s(s(s(sz))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s(\lambda s''.s''(s''(s''(s''(s''(s(s(s(sz)))))))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda s.\lambda z .s(s(s(s(s(s(s(s(sz)))))))) = \overline{9}
            \]
        \end{exercise}

        \subsubsection{Producto}
        Para el producto de m y n la ídea es anidar la operación: n + n, m veces reemplazando las aparaciones de de la variable s en el numeral m por sum(n ... , esta operación está definida de la siguiente manera:

        \begin{definition}[Definición del producto para los numerales de Church.]
            $$prod:  \; \\lambda m.\lambda n.m\; \bar{0} \; (sum\;n)$$
        \end{definition}

        \begin{exercise}
            Utiliza la definición de la función prod evaluar la siguiente  $\lambda$-expresión
            \[
                    prod  \overline{2} \; \overline{3}
            \]
            \[
                   = (\lambda m\lambda n.m\; \overline{0} \; (sum \; n)) \;  \lambda z\lambda s.s(sz) \; \overline{3} \rightarrow_\beta (\lambda n.(\lambda z\lambda s.s(sz)) \; \overline{0} \; (sum \; n)) \; \overline{3} 
            \]
            \[
                    \rightarrow_\beta (\lambda n.(\lambda s.s(s\overline{0}))\; (sum n)) \; \overline{3} \rightarrow_\beta  (\lambda n.(sum \; n \; (sum \; n \; \overline{0})) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (sum \; \overline{3} \; (sum \; \overline{3} \; \overline{0})) = 
            \]
            \[
                    \scalemath{0.8}{
                        \lambda m\lambda n\lambda s\lambda z.n(m \; z \; s) \; s \; \lambda z'\lambda s'.s'(s'(s'z')) \; (\lambda m'\lambda n'\lambda s''\lambda z''.n'(m' \; z'' \; s'') \; s \; \lambda z'''\lambda s'''.s'''(s'''(s'''z''')) \; \lambda z''''\lambda s''''.z'''') 
                    }
            \]
            \[
                    \text{resolveremos por partes la suma dado que la notación crece muy rápido y es poco legible}
            \]
            \[
                    sum  \overline{3} \; \overline{0} = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s ) \; \lambda z'\lambda s'.z' \; \overline{3}
            \]
            \[
                    \rightarrow_\beta  (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.z') \; z \; s) \; s) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta  (\lambda n\lambda z\lambda s.n(\lambda s'.z \; s) \; s) \; \overline{3} \rightarrow_\beta \rightarrow_\beta  (\lambda n\lambda z\lambda s.n \; z \; s) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta   \lambda z\lambda s.(\overline{3} \; z \; s \;) = \; \lambda z\lambda s.((\lambda z'\lambda s'.s'(s'(s'z'))) \; z \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.(\lambda s'.s'(s'(s'(z))) \; s) \rightarrow_\beta \lambda z\lambda s.s(s(sz)) = \overline{3} 
            \]
            \[
                    \textbf{sum } \; \overline{3} \; \overline{3} = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s ) \; \lambda z'\lambda s's'(s'(s'.z')) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s's'(s'(s'.z'))) \; z \; s) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n((\lambda s's'(s'(s'.z))) \; s) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n \; (s(s(s.z))) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.((\overline{3}) \; (s(s(s.z))) \; s) = \lambda m\lambda n\lambda z\lambda s.(( \lambda z'\lambda s'.s'(s'(s'z'))) \; (s(s(s.z))) \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.((\lambda s'.s'(s'(s'(s(s(s.z))))))  \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.\lambda s.s(s(s(s(s(s.z))))) = \overline{6}
            \]
        \end{exercise}

        \section{Datos estructurados en el Cálculo Lambda}

            En el Cálculo Lambda es posible definir estructuras para almacenar información junto con las funciones para recuperar los elementos guardados en éllas.
            Revisaremos dos: La estructura más simple serán las tuplas junto con sus proyecciones first y second que ayudan a sentar la base para definir una estructura más compleja, las listas. Con su respectiva función para obtener la cabeza y la cola. Juntas proveen un mecanismo de almacenamiento en este sistema.
    
            \subsection{Tuplas}

                La tupla es la estructura que representa a un par compuesto por elemento izquierdo y derecho o primero y segundo. En el cálculo Lambda se define como la función que tiene dos argumentos uno para cada elemento. Y una función b (el argumento f representa al elemento primero o $first$ en inglés y el argumento s representa el segundo o $second$).
        
                \begin{definition}[Constructor de una tupla junto con la proyección de ambos elementos]
            
                    Constructor
                        $$\mathsf{pair} = \lambda f\lambda s\lambda b. bfs$$
                    Proyección del primer elemento
                        $$\mathsf{fst} = \lambda p.p \ True$$
                    Proyección del segundo elemento
                        $$\mathsf{snd} = \lambda p.p \ False$$
                \end{definition}

                Donde las proyecciones se apoyan de la propiedad de los booleanos de regresar el primer argumento para el caso de True y el segundo en el caso de False\footnote{Véase la sección de este capítulo: \textbf{Booleanos}}. \\
                En general se tienen las siguiente reducciones cuando se aplican estos operadores a cualquier tupla:

                $${\sf fst}\;({\sf pair}\;{\sf a} \; {\sf b}) \to_\beta ^* {\sf a}$$
                $${\sf snd}\;({\sf pair}\;{\sf a} \; {\sf b}) \to_\beta ^* {\sf b}$$ 

            \subsection{Listas}
            Las listas en el Cálculo Lambda se apoyan de los constructores de la tupla para ir añadiendo elementos en la cabeza al cuerpo de una lista anidando las tuplas un elemento a la vez. 
            El único inconveniente es que no hay un constructor para la lista vacía, éste será representado por una $\lambda$-expresión que sea $\alpha$-equivalemte al booleano False. \\\\
            La definición de las listas resulta ser una aplicación de los contsturctores para tuplas, sus funciones y la constante boleana False como se ve a continuación:

            \begin{definition}[Constructores para listas en Cálculo Lambda junto con sus funciones]
                \textbf{Definición de la Lista vacía}
                $${\sf nil}  = False$$
                \textbf{Constructor de una lista tomando una cabeza y una cola}
                $${\sf cons} = pair$$
                \textbf{función para obtener la cabeza de la lista}
                $${\sf head}  = fst$$
                \textbf{función para obtener la cola de la lista}
                $${\sf tail} = snd$$
            \end{definition}

        \section{Propiedades semánitcas del Cálculo Lambda}
            En el capítulo 5. Sémantica se mencionaron brevemente las propiedades de la evaluación para expresiones de EAB. En esta sección discutiremos cómo el Cálculo Lambda interactúa con las mismas propiedades con la ayuda de ejercicios que nos permitan entender cada propiedad aplicada en este modelo.\\
            
                \subsection{No terminación}
                    Hemos tratado brevemente las propiedad de la evaluación para expresiones bien formadas de \textsf{EAB} en donde éstas se evaluarán a un valor (número o booleano) en algún punto de su ejecución. 
                    No obstante esta propiedad no se cumple para el Cálculo Lambda como se puede ver a continuación:
                    \begin{exercise}
                        Demuestra o da un contraejemplo de por qué la porpiedad de terminación para el Cálculo Lámnbda es válida.\\\\
                        Consideremos el siguiente par de $\lambda$-expresiones:\\
                        $$ \omega = \lambda x.xx$$
                        $$ \Omega = \omega \omega$$
                        $$ \Omega = \omega \omega = (\lambda x.xx) \omega \omega \rightarrow_\beta \omega \omega$$
                        En general esta expresión cumple que en cada $\beta$-reducción se tiene la misma expresión $\Omega$.
                        Por lo tanto una expresión bien formada del Cálculo Lambda no necesariamente tiene una forma normal.
                    \end{exercise}

                \subsection{No determinismo}
                    En los lenguajes de programación una propiedad deseable es la propiedad determinista de los programas, es decir, que la evaluación que se haga para una expresión sea siempre la misma. El Cálculo Lambda carece de esta propiedad. Dependiendo del segmento $redex$ que escogamos para aplicar la $\beta$-reducción el reducto puede diferir, tomemos como ejemplo la siguiente $\lambda$-expresión:
                    $$(\lambda z.(\lambda y.z)a)b$$
                    Si tomamos como redex la expresión completa, se obtine la siguiente evaluación: $$\underline{(\lambda z.(\lambda y.z)a)b} \rightarrow_\beta (\lambda y.b)a$$
                    Si por el contrario tomamos como redex la lambda interna se obtiene: $$(\lambda z.\underline{(\lambda y.z)a})b \rightarrow_\beta (\lambda z.z)b$$
                    En ambas evaluaciones el resultado al que se llega al terminar de evaluar la expresión es la variable b sin importar cuál redex se haya escogido para la evaluación.\\\\
                    Esta característica del Cálculo Lambda no supone una desventaja por el principio de confluencia.

                \subsection{Confluencia}
                    El principio de confluencia nos asegura que dadas dos dos evaluaciones distintas para la misma $\lambda$-expresión, éstas convergen en un término común en algún punto de la evaluación:

                    \begin{theorem}[Propiedad de Church-Rosser] Si $e\to_\beta^* e_1$ y $e\to_\beta^*e_2$ entonces existe un término $t$ tal que  $e_1\to_\beta^* t$ y $e_2\to_\beta^* t$.
                    \end{theorem}


                    \begin{corollary}[Unicidad de formas normales] Para cualquier expresión $e$ si $e\to_\beta^*e_f$ y $e\to_\beta^*e_f'$ tal que tanto $e_f$ como $e_f'$ están bloqueadas, entonces $e_f = e_f'$ salvo $\alpha$-equivalencias. Es decir, la forma normal de una expresión es única.
                    \end{corollary}

        \section{Combinadores de punto fijo}
                    El Cálculo Lambda por si mísmo no posee un mecanisno iterativo que nos permita formar alguna secuencia de control como los ciclos $for$ o $while$ como en la mayoría de los lenguajes de programación modernos.\\\\
                    Su naturaleza funcional nos hace preguntarnos si podemos emplear un mecanismo mas afín como la recursión para definir funciones que iteren sobre algún parámetro.\\\\
                    El mecanismo de recursión para el Cálculo Lambda no viene dado por la definición que hasta el momento hemos revisado, se precisa de la introducción de los Combinadores de Punto Fijo que capturan la escencia del principio de recursión general en computación, ésto es:
                    $$ rec\ F\ =\ F\ (rec\ F) $$
                    De esta forma, si definimos una $\lambda$-expresión rec que nos permita "autoaplicarse" la función que toma como parámetro podemos definir cualquier función recursiva aplicando n veces la función.
                    $$rec\ F = F(rec\ F) = F(\ F(rec\ F)) =\ ...\ F(\ F(\ F(\ ...\ )))$$
                    
                    \begin{definition}[Combinador de punto fijo] Un lambda término cerrado $F$ es un combinador de punto fijo sí y sólo si cumple alguna de las siguientes condiciones:
                        \begin{enumerate}
                            \item $F\,g\to_\beta^*g\,(F\,g)$
                            \item $F\,g\equiv_\beta g\,(F\,g)$, es decir, existe un término $t$ tal que $F\,g\to_\beta^*t$ y $g\,(F\,g)\to_\beta^*t$
                        \end{enumerate}
                    \end{definition}

                    Existen diferentes $\lambda$-expresiones que cumplen con la definición provista anteriormente, uno de los combinadores mas sencillos y populares es el Combinador $\Y$ que se define de la siguiente forma:

                    \begin{definition}(Combinador $\Y$) también conocido como Curry-Rosser:
                        $$\Y = \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$$
                    \end{definition}
    

                    \begin{exercise} Demuestra que el combinador  $\Y$ es un combinador de punto fijo.
                        \[
                            \begin{array}{cl}
                            &\Y\,g\\
                            &(\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))\,g\\
                            \to_\beta&(\lambda x.g(xx))(\lambda x.g(xx))\\
                            \to_\beta&g((\lambda x.g(xx))(\lambda x.g(xx)))\\
                            \end{array}
                        \]
                    
                        Tomando la segunda parte de la igualdad y desarrollando obtenemos
                    
                        \[
                            \begin{array}{cl}
                            &g\,(\Y\,g)\\
                            &g\,((\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))\,g)\\
                            \to_\beta&g\,((\lambda x.g(xx))(\lambda x.g(xx)))
                            \end{array}
                        \]
                    
                        de esta forma podemos concluir que $\Y\,g\equiv_\beta g\,(\Y\,g)$, entonces $\Y$ es un combinador de punto fijo.
                    \end{exercise}

                    \newpage

            \section{Ejercicios para el lector}

                \begin{exercise}
                    Continuando con la definición \textbf{4.1} de los booleanos y sus operadores en el Cálculo Lambda implementa los siguientes operadores:
                    \[IF\]
                    \[OR\]
                \end{exercise}

                \begin{exercise}
                    Verifica las propiedas de la semántica operacional para cada operador booleano según la definición 4.2:

                        $$\mathsf{if}\,true\,e_1\,e_2 \to_\beta^* e_1$$ 
                        $$\mathsf{if}\,false\,e_1\,e_2 \to_\beta^* e_2$$ 
                        $$\mathsf{not}\,true\to_\beta^* false$$
                        $$\mathsf{not}\,false\to_\beta^* true$$
                        $$\mathsf{and}\,false\,b\to_\beta^* false$$
                        $$\mathsf{and}\,true\,b\to_\beta^* b$$
                        $$\mathsf{or}\,true\,b\to_\beta^* true$$
                        $$\mathsf{or}\,false\,b\to_\beta^* b$$
                        
                \end{exercise}


                \begin{exercise}
                    Resuelve las siguientes operaciones de los númerales de Church (el abuso de notación para simplificar $\lambda$-expresiones está permitido con el fin de tener una representación más compacta cuando sea posible)
                    \[
                            prod\ (sum\ \overline{7}\ \overline{4})\ \overline{2}
                    \]
                    \[
                            IsZero (prod\ \overline{1}\ \overline{0})
                    \]
                    \[
                            IsZero( sum\ \overline{3}\ (prod\ \overline{5}\ \overline{4}))
                    \]
                \end{exercise}  

                \begin{exercise}
                    Siguiendo la definición \textbf{6.2} para Listas en el Cálculo Lambda define la función $IsNil$ que se comporta de la siguiente forma
                    \[ IsNil\ []\ =\ \textbf{True} \]
                    \[ IsNil\ (x:xs)\  =\ \textbf{False}\]
                \end{exercise}

                \begin{exercise}
                    Encuentra la forma normal de las siguientes $\lambda$-expresiones, si no es posible explica por qué.\\
                    \[
                        (\lambda y.yy)(\lambda z.zz)(\lambda \alpha . \lambda \beta . \alpha \beta \alpha) False \; \overline{0}
                    \]
                    \[
                        ((\lambda z. \lambda y. \lambda u.uzy)(\lambda x.x)(\lambda wv.wv) \; \overline{0} \; \overline{1}) \; True 
                    \]
                \end{exercise}

                \begin{exercise}
                    Para cada una de las siguientes $\lambda$-expresiones demuestra que son combinadores de punto fijo.\\
                    
                    \begin{itemize}
                        \item Turing $V\ =\ UU$ en donde $U\ =\ \lambda f.\lambda x.x(ffx)$
                        \item Estricto $Z\ =\ \lambda f.(\lambda x.f(\lambda v.xxv))(\lambda x.f(\lambda v.xxv))$
                    \end{itemize}
                    
                \end{exercise}

                \begin{exercise}
                    Utilizando cualquiera de los combinadores de punto fijo implemeta la función recursiva Factorial para los numerales de Church en el Cálculo Lambda.
                    \[ Factorial\ 1\ =\ 1 \]
                    \[ Factorial\ n\ =\ n\ *\ factorial\ n-1\]
                    Adicionalmente muestra la ejecución para n = $\overline{3}$
                \end{exercise}

                \begin{exercise}
                    Utilizando algún combinador de punto fijo implemeta la función recursiva Fibonacci para los numerales de Church en el cálculo Lambda.
                    \[ Fibonacci\ 0\ =\ 0 \]
                    \[ Fibonacci\ 1\ =\ 1 \]
                    \[ Fibonacci\ n\ =\ Fibonacci\ n-1\ +\ Fibonacci\ n-2\]
                    Adicionalmente muestra la ejecución para n = $\overline{3}$
                \end{exercise}

                \begin{exercise}
                    Utilizando el combinador $\mathbf{Y}$, define la función concat para la representación de listas en el Cálculo Lambda.

                    \[
                        concat\ []\ (y:ys)\ =\ (y:ys)
                    \]
                    \[
                        concat\ (x:xs)\ (y:ys)\ = x:concat(xs\ (y:ys))
                    \]
                \end{exercise}

                \begin{exercise}
                    Utilizando cualquier combinador de punto fijo resuelve lo siguiente:\\
                    
                    1. Define la función reversa para las listas del Cálculo Lambda. \\
                    \[
                        rev\ []\ =\ []
                    \]
                    \[
                        rev\ (x:xs)\ =\ rev\ xs\ ++\ [x]
                    \]
                    2. Aplica la función para obtener la reversa de la lista: pair 1 (pair 2 (pair 3 False))
                \end{exercise}

                \begin{exercise}
                    Utilizando el combinador $\mathbf{Y}$ contesta lo siguiente: \\
                    
                    1. Da una definición de la función de exponenciación para los numerales de Church.\\
                    2. Resuelve la función para exp $\overline{4} \; \overline{2}$.
                \end{exercise}

%https://blog.brunobonacci.com/2017/10/08/lambda-calculus-and-boolean-logic/
%https://stackoverflow.com/questions/52548280/implementing-fibonacci-sequence-using-pure-lambda-calculus-and-church-numerals-i
%https://drive.google.com/file/d/1MM6Lu417pwH_zKl0kITA0EzSfJL8grP9/view
%

                    
            