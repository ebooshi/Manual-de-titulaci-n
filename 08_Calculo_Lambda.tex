%    Quinto Capítulo capítulo: Cálclo Lambda.
%    Ejercicios por Barón L. Miguel.
%    Teoría por Javier Enríquez Mendoza.
%    Empezado el 18/1/23
%    Concluido el 2/27/23

%Gatito lambda
\begin{figure}[htbp]
    \centerline{\includegraphics[scale=0.20]{assets/05_gatito_lambda.jpg}}       
\end{figure}


%Introducción
Cuando pensamos en el nacimiento de las computadoras podemos inmediatamente asociarlo con las máquinas de Turing, un sistema de transición que se ha estudiado con anterioridad en materias como autómatas y lenguajes formales\footnote{Conforme al plan de estudios que se imparte desde el 2013 en la Facultad de Ciencias de la Universidad Nacional Autónoma de México con clave de asignatura 1425. } siendo el más reconocido cuando se habla de modelos de cómputo y la definición de conceptos como: computabilidad, algoritmo o complejidad. Términos apenas formalizados en 1936.\\\\
En este curso estudiaremos un modelo equivalente de cómputo, es aquí donde Alonzo Church nos introduce en 1928 a su aproximación de un sistema formal basado en el concepto de ''función'' con las primitivas de ''abstracción'' y ''aplicación'' que fungiría como fundamento lógico para sustituir el la teoría de conjuntos de Zermelo-Fraenkel y la teoría de tipos de Russell. Este sistema fue demostrado como inconsistente por sus dos alumnos Stephen Kleene y Barkley Russell pero no todo sería desechado, conservando la parte del manejo de funciones particularmente rica, consistente y sorprendentemente equivalente al modelo de Alan Turing, a este modelo se le conoce como Cálculo Lambda\footnote{Extraído de  \hyperlink{108}{[108]}}.\\


\subsubsection{Objetivo}
Revisar la composición del Cálculo Lambda mediante el estudio de la sintáxis, semántica operacional y la representación de tipos primitivos en este modelo de cómputo, así como las propiedades inherentes a la semántica del cálculo junto con los sistemas de recursión para la evaluación de $\lambda$-expresiones. \\ 

\subsubsection{Planteamiento}
En este capítulo se revisará la sintáxis concreta del Cálculo Lámbda para generar $\lambda$-expresiones junto con
la semántica operacional del cálculo, basándonos en la operación de sustitución sintáctica ([variable := valor]) conocida como $\beta$-reducción.\\\\
También se abordará la definición de los booleanos junto con los operadores lógicos, estructuras de datos (tuplas, proyecciones, listas) y los numerales de Chruch con operadores aritméticos mismos que se espera el lector pueda manipular, razonar y resolver en la sección de ejercicios. \\\\
Finalmente se introducirá el sistema de recursión para el Cálculo Lambda con los operadores de punto fijo.


\section{Sintáxis del Cálculo Lambda}
    El cálculo lambda es un modelo simple, su sintáxis comprende sólo tres categorías de términos\footnote{Definición extraída de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y \hyperlink{110}{[110]}}:
    \begin{itemize}
        \item Variables: Los elementos de esta categoría pertenecen a un conjunto finito de letras mínusculas, generalmente las últimas del alfabeto (w, x, y, z) y son las expresiones lambda más simples.\\
        \item Abstracciones: Esta categoría engloba los términos que definen a las funciones anónimas, compuestas por tres elementos: el primero es la letra griega $\lambda$, el segundo es la variable que estará ligada en el cuerpo de la expresión y por último el cuerpo mismo de la función denotado como $e$, estas se representan de la forma $\lambda x.e$.\\
        \item Aplicación: Esta categoría engloba a las expresiones que representan la aplicación de un argumento a una función. estas son representadas como $e_1\,e_2$ y su evaluación será la sustitución sintáctica ([:=]).
    \end{itemize}

    \begin{definition}[Sintaxis concreta del Cálculo Lambda] Definimos el juicio $l \; \lambda$ que indica que $l$ es una expresión válida en el Cálculo Lambda. A estas expresiones las denominaremos  $\lambda-$expresiones\footnote{Definición extraída de \hyperlink{5}{[5]},  \hyperlink{12}{[12]}, \hyperlink{108}{[108]}, \hyperlink{109}{[109]}}.
    
        \[
            \begin{array}{ccccc}
                \inference{x\;{\sf var}}{x\;\lambda}[$var$]&\quad&
                \inference{x\;{\sf var}&e\;\lambda}{\lambda x.e\;\lambda}[$abs$]&\quad&
                \inference{e_1\;\lambda&e_2\;\lambda}{e_1\,e_2\;\lambda}[$app$]
            \end{array}
        \]
    \end{definition}

\bigskip

    \begin{exercise}
        Para las siguientes $\lambda-$expresiones anota a la derecha a que categoría de la sintáxis del Cálculo Lambda corresponde dicho término.
       \begin{center}
          \begin{tabular}{ c c }

             $x$ 			  	 	  & \text{variable} \\ 
             $y$		 	 	 	  & \text{variable}  \\
             $\lambda x.x$	  		  & \text{función anónima} \\
             $\lambda x.y$   	  		  & \text{función anónima}  \\
             ($\lambda x.x)v$  	    	  & \text{aplicación} \\
             ($\lambda x.x)v'$	 	 	  & \text{aplicación} \\
             $\lambda x.\lambda y.xy$           & \text{función anónima}\\
             $x(\lambda x.y)$ 			  & \text{aplicación}\\
             $(\lambda x.x)(\lambda y.y)$     &  \text{aplicación}	
 
        \end{tabular}
      \end{center}
    \end{exercise}

    En el ejemplo anterior, la tercer $\lambda-$expresión corresponde a la función identidad que regresa el argumento que es pasado como parámetro. La cuarta $\lambda-$expresión corresponde a la función constante que siempre regresa el mismo valor sin importar el parámetro que recibe. La sétima $\lambda-$expresión es la ilustración de como se puede anidar dos funciones anónimas para construir una sola de dos parámetros \footnote{A este proceso se le conoce como currificación en honor a Haskell Curry y nos permite anidar tantas funciones como parámetros necesitemos, este tema será revisado a detalle más adelante en este capítulo}. 

\section{$\alpha$-equivalencia en el Cálculo Lambda}

    En el Cálculo Lambda se tiene un constructor similar al operador \textsf{let} que tiene una variable ligada, un alcance asociado a ella y con esto el concepto de $\alpha$-equivalencia fue introducido para expresiones que difieren a lo más en el nombrado de sus variables ligadas. 
    \begin{definition}[$\alpha$-equivalencia en el Cálculo Lambda]  Dos $\lambda-$expresiones $e_1$ y $e_2$ son $\alpha$-equivalentes si y sólo si solo difieren a lo mas en el nombre de las variables ligadas\footnote{Definición extraída de  \hyperlink{5}{[5]},  y  \hyperlink{12}{[12]}}. Esto es denotado como: $$e_1 \equiv_{\alpha} e_2 $$

     Por ejemplo, las expresiones:
    \[
        \begin{array}{ccc}
        \lambda x.x &\quad& \lambda z.z
        \end{array}
    \]
    \noindent
    son $\alpha$-equivalentes y se representa como: $$\lambda x.x\equiv_{\alpha}\lambda z.z$$
    \end{definition}


    \section{Semántica operacional del Cálculo Lambda}
    Cómo se discutió brevemente en la introducción del capítulo, la semántica operacional del Cálculo Lambda está definida por la sustitución sintáctica. 
A la operación de sustituir los términos que concuerden con la variable del operador en la $\lambda-$expresión se le conoce como $\beta$-reducción y se representa con el símbolo $\to_\beta$. 


    \begin{definition}[Semántica operacional del Cálculo Lambda] La semántica operacional está definida por la siguiente regla\footnote{Definición formulada de \hyperlink{5}{[5]},  \hyperlink{12}{[12]},  \hyperlink{108}{[108]} y  \hyperlink{109}{[109]}}: 

    $$(\lambda x.t)\,s \to_\beta t[x:=s] \quad \text{($\beta$-reducción)}$$
    Donde se tienen los siguientes casos según la composición de la $\lambda-$expresión:\\
        \begin{itemize}
        \item $x[x:=r] = r$. 
        \item $y[x:=r] = y$ si $x\neq y$.
        \item $(ts)[x:=r] = t[x:=r]s[x:=r]$.
        \item $(\lambda y.t)[x:=r] = \lambda y.t[x:=r]$ donde $y\notin FV(r)$.
        \end{itemize}
	\bigskip
	Es importante remarcar que la asociatividad de la aplicación de la $\beta$-reducción es hacia la izquierda
    \end{definition}
    
    \begin{exercise}
    Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
    $$e= (\lambda x.z)y$$
    \[ (\lambda x.z)y \rightarrow_\beta  z [x := y]\]
    \[ = z \]
    \end{exercise}

    \begin{exercise}
        Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
        $$e = (\lambda x.x)(\lambda y.yy) z$$
        \[ (\lambda x.x)(\lambda y.yy) z \rightarrow_\beta (x[x:=\lambda y.yy])(z)\]
        \[ = (\lambda y.yy)(z) \rightarrow_\beta yy[y:=z]\]
        \[ =  y[y:=z]y[y:=z] = zz\]
       \[= zz \]
    \end{exercise}

    \begin{exercise}
        Utiliza la definición de $\beta$-reducción para evaluar la siguiente $\lambda-$expresión.
        $$e= (\lambda x.\lambda y.xy)(\lambda z.z)(w)$$
        \[(\lambda x.\lambda y.xy)(\lambda z.z)(w) \rightarrow_\beta (\lambda y.xy[x := \lambda z.z])(w) \]
        \[ =  (\lambda y.x[x := \lambda z.z]y[x := \lambda z.z])(w) = (\lambda y.(\lambda z.z)y)(w) \]
        \[ (\lambda y.(\lambda z.z)y)(w) \rightarrow_\beta (\lambda y.z[z := y])(w) \]
        \[ = (\lambda y.y)(w) \rightarrow_\beta y[y := w] \]
        \[ = w \]
    \end{exercise}

    \section{Definibilidad Lambda}
    En el Cálculo Lambda las funciones son tipos primitivos, estas pueden ser pasadas como argumentos entre sí y generar nuevos elementos válidos para el sistema. Si extrapolamos esta idea para definir entidades primitivas nos encontraremos nombrando funciones para construir los elementos que pertenecen a esta categoría.\\\\
 En el contexto de los lenguajes de programación las entidades primitivas o tipos primitivos nos son proporcionados por la biblioteca estándar del lenguaje (\textsf{int}, \textsf{char}, \textsf{boo}l, etc.). En el Cálculo Lambda estos tipos primitivos serán definidos por funciones anónimas a las que convendremos un nombre para facilitar su representación\footnote{Información consultada de \hyperlink{108}{[108]} y  \hyperlink{109}{[109]}}.

    \subsection{Booleanos y operadores lógicos}
    Las constantes booleanas \textsf{True} y \textsf{False} son entidades opuestas, una es el valor contrario de la otra. Si tratemos de trasladar esta idea a un par de funciones podemos pensar en algo como:
    la función que toma dos argumentos y regresa el primero es el opuesto de la función que toma dos argumentos y regresa el segundo\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{110}{[110]} y  \hyperlink{111}{[111]}}:
    \[
        \lambda x.\lambda y.x
    \]
    \[
        \lambda x.\lambda y.y
    \]
    Estas entidades están haciendo exactamente lo contrario que hace la otra, como las funciones son objetos primitivos en el Cálculo Lambda entonces definiremos este par de elementos como nuestro \textsf{True} y nuestro \textsf{False} respectivamente.

    De esta forma podemos definir funciones que a su vez, construyan la lógica booleana y nos permitan operar instrucciones de control.
    \begin{definition}[Operadores lógicos para el cálculo Lambda] Definimos las constantes booleanas \textsf{True}, \textsf{False}, \textsf{NOT} y \textsf{AND} con las siguientes funciones\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y  \hyperlink{110}{[110]}}:\\

        \begin{itemize}
            \item \textsf{True}  $=_{def}$  $\lambda x.\lambda y.x$ 
            \item \textsf{False}  $=_{def}$   $\lambda x.\lambda y.y$ 
            \item\textsf{NOT}   $=_{def}$   $\lambda z. z  (\textsf{False}) (\textsf{True})$ 
            \item \textsf{AND}  $=_{def}$  $\lambda x.\lambda y. xy (\textsf{False})$ 
	     \item \textsf{If}      $=_{def}$ $\lambda f.\lambda a.\lambda b.fab $
        \end{itemize}
	  \bigskip
	Es importante mencionar que para estas definiciones estamos abusando de la notación al no escribir la definición de las constantes y usar su nombre directamente. Esto es para ahorrar espacio en los desarrollos y estará permitido su uso en los ejercicios posteriores.
    \end{definition}

    Para el operador \textsf{NOT} la lógica de ejecución es aplicar la función identidad al parámetro de entrada, si este es \textsf{True} entonces se regresará el primer argumento, en este caso la constante \textsf{False}: \[ (\lambda x.x (\textsf{False})(\textsf{True}))\textsf{True} \to_\beta^* \textsf{True}(\textsf{False})(\textsf{True}) \to_\beta^* \textsf{False}\] 
	Sí al contrario el parámetro de entrada es \textsf{False} este regresará el segundo argumento, en este caso la constante \textsf{True}: \[ (\lambda x.x (\textsf{False})(\textsf{True}))\textsf{False} \to_\beta^* \textsf{False}(\textsf{False})(\textsf{True}) \to_\beta^* \textsf{True}\]
    En el caso del operador \textsf{AND} la lógica subyacientes es que si el primer parámetro es un \textsf{False} no importa el segundo parámetro que reciba, siempre regresaremos la constante \textsf{False}:
\[ (\lambda x.\lambda y. xy (\textsf{False}))\ \textsf{False}\  w \to_\beta^* \textsf{False}\ w\ (\textsf{False}) \to_\beta^* \textsf{False}  \]
Si recibe como primer parámetro la constante \textsf{True} entonces el resultado será el segundo parámetro:
\[ (\lambda x.\lambda y. xy (\textsf{False}))\ \textsf{True}\  w \to_\beta^* \textsf{True}\ w\ (\textsf{False}) \to_\beta^* w  \]
Notemos que la única forma de evaluar la instrucción \textsf{AND} como \textsf{True} es si se recibe esta constante dos veces.

Para el Cálculo Lambda es desable entonces que los operadores anteriormente definidos, aplicando un número finito de veces la regla de $\to_\beta$ se obtengan los siguientes resultados:
   \begin{center}

        \begin{itemize} \centering
            \item $\mathsf{If}\,\textsf{True}\,e_1\,e_2 \to_\beta^* e_1$ 
            \item $\mathsf{If}\,\textsf{False}\,e_1\,e_2 \to_\beta^* e_2$ 
            \item $\mathsf{NOT}\,\textsf{True}\to_\beta^* \textsf{False}$
            \item $\mathsf{NOT}\,\textsf{False}\to_\beta^* \textsf{True}$
            \item $\mathsf{AND}\,\textsf{False}\,b\to_\beta^* \textsf{False}$
            \item $\mathsf{AND}\,\textsf{True}\,b\to_\beta^* b$
        \end{itemize}
   \end{center} 

     \section{Aritmética del Cálculo Lambda}
        En los lenguajes de programación otro tipo primitivo que es de vital importancia y que se nos es proporcionado por la biblioteca estándar son los números enteros.
        Estas entidades también tienen una representación en el Cálculo Lambda como funciones.\\\\
        La construcción de los números naturales se obtiene al aplicar la función sucesor al cero, de tal forma que no tenemos el número dos, tenemos dos veces la aplicación de la función sucesor al cero: \textit{s(s(0))}, en Cálculo Lambda esta idea se mantiene vigente, los números serán la aplicación anidada de una función a la constante cero. 
     \subsection{Numerales de Church}
        Church introdujó los numerales como la abstracción de dos parámetros ''$s$'' y ''$z$'' en una función anónima, de tal forma que si se desea representar al n-ésimo número este sea formado por la aplicación de $s$ a $z$, n veces\footnote{Definición formulada de \hyperlink{108}{[108]},  \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}:

    \begin{itemize}
        \item $\bar{0}=_{def}\lambda s.\lambda z.z$
        \item $\bar{1}=_{def}\lambda s.\lambda z.sz$
        \item $\bar{2}=_{def}\lambda s.\lambda z.s(sz)$
        \item $\bar{n}=_{def}\lambda s.\lambda z.\underbrace{s(\ldots(s}_{n\;veces} z)\ldots)$
    \end{itemize}

    \subsection{Funciones aritméticas}
	Para los numerales de Church podemos difinir operadores aritméticos similares a los que se utilizan cuando trabajamos con los números enteros, estos operadores nos permitirán computar valores y estarán definidos como una función donde los operandos serán los argumentos de entrada.

    \subsubsection{Función sucesor}
        Comenzamos el estudio de las funciones aritméticas para el Cálculo Lambda definiendo la función sucesor para los numerales de Church, esta función recibe un numeral y construye el sucesor añadiendo un símbolo ''$s$'' al inicio.
        \begin{definition}[Función sucesor para los numerales de Church]\footnote{Definición extraída de \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}
            $$\textsf{suc} =_{def} \lambda n\lambda z\lambda s. s(n \; z \; s)$$
        \end{definition}
     
        \begin{exercise}
            Utiliza la definición de la función sucesor para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{suc } \overline{2}
            \]
            \[
                (\lambda n\lambda z\lambda s.s(n \; z \; s) ) \; \lambda z'\lambda s'.s'(s'z') \rightarrow_\beta 
            \]
		\[
			\lambda z\lambda s.s((\lambda z'\lambda s'.s'(s'z'))\ z \; s) \rightarrow_\beta 
		\]	
            \[
                 \lambda z\lambda s.s(\lambda s'.s'(s'z)\ s) \rightarrow_\beta
            \]
		\[
			\lambda s\lambda s.s(s(sz)) \rightarrow_\beta
		\]
            \[
                = \overline{3}
            \]
        \end{exercise}

        \begin{exercise}
            Utiliza la definición de la función sucesor para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{suc } \overline{5}
            \]
            \[
                (\lambda n\lambda z\lambda s.s(n\ z\ s)) \; \lambda z'\lambda s'.s'(s'(s'(s'(s' \; z')))) \rightarrow_\beta
            \]
		\[
			 \lambda z\lambda s.s((\lambda z'\lambda s'.s'(s'(s'(s'(s'z')))))\ z\ s)  \rightarrow_\beta	
		\]
            \[
                \lambda z\lambda s.s(\lambda s'.s'(s'(s'(s'(s\;z))))\ s) \rightarrow_\beta 
            \]
		\[
			\lambda s\lambda z.s(s(s(s(s(sz)))))
		\]
            \[
                = \overline{6}
            \]
        \end{exercise}

        \subsubsection{IsZero}
        	Este operador está diseñado para regresar \textsf{True} cuando el numeral que recibe como parámetro corresponde al numeral $\overline{0}$. En caso contrario la función regresa \textsf{False} y está definida de la siguiente forma.
        
	\begin{definition}[Función IsZero para numerales de Church]\footnote{Definición extraída de \hyperlink{2}{[2]},  \hyperlink{5}{[5]} y \hyperlink{12}{[12]}}
            $$\textsf{IsZero} =_{def}  \; \lambda m. m\;\textsf{True} \;(\lambda x.\textsf{False})$$
        \end{definition}

        \begin{exercise}
            Utiliza las definición de la función \textsf{IsZero} para evaluar la siguiente $\lambda$-expresión
            \[
                \textsf{IsZero}  \; \overline{2}
            \]
            \[
                (\lambda m. m\;\textsf{True} \;(\lambda x.\textsf{False})) \; \lambda z\lambda s.s(s\;z) \rightarrow_\beta 
            \]
		\[
			(\lambda z\lambda s.s(s\:z)) \; \textsf{True} \; (\lambda x.\textsf{False})  \rightarrow_\beta 
		\]
            \[
                	(\lambda s.s(s\: \textsf{True})) \; (\lambda x.\textsf{False}) \rightarrow_\beta  
            \]
		\[
			(\lambda x.\textsf{false}) \; ((\lambda x.\textsf{false}) \; \textsf{true}))) \rightarrow_\beta  
		\]
            \[
                 \rightarrow_\beta  (\lambda x.\textsf{False}) \; \textsf{false} \rightarrow_\beta 
            \]
		\[
			\textsf{False}
		\]

        \end{exercise}

        \begin{exercise}
            Utiliza las definición de la función \textsf{IsZero} para evaluar la siguiente $\lambda$-expresión
            \[
                \textsf{IsZero} \; \overline{0}
            \]
            \[
                (\lambda m. m\textsf{True} \; (\lambda x.\textsf{False})) \; \lambda z\lambda s.z \rightarrow_\beta 
            \]
		\[
			(\lambda z\lambda s.z) \; \textsf{True} \; (\lambda x.\textsf{False}) \rightarrow_\beta 
		\]
            \[
                   (\lambda s.\textsf{True}) \; \lambda x.\textsf{False} \rightarrow_\beta 
            \]
		\[
			\textsf{True}
		\]
        \end{exercise}
        

    \subsubsection{Suma}
        Esta función se define de forma similar a la función suma para los números naturales  donde se reciben dos argumentos $m$ y $n$ y se aplica n veces la función sucesor al número m.

           \[ m + 0 = m \]
           \[ m + s(n) = s(m + n) \]


        \begin{definition}[Definición de la suma para los numerales de Church]\footnote{Definición extraída de \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}
            $$\textsf{sum} =_{def}  \; \lambda m\lambda n\lambda s\lambda z.n(m \; z \; s) \; s$$
        \end{definition}

        \begin{exercise}
            Utiliza la definición de la función \textsf{sum} para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{sum}\  \overline{2} \; \overline{3} 
            \]
            \[
                = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s) \; \lambda z'\lambda s'.s'(s'z') \;\; \lambda z''\lambda s''.s''(s''(s''z'')) \rightarrow_\beta 
            \]
            \[
                (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.s'(s'z')) \; z \; s) \; s) \; \lambda z''\lambda s''.s''(s''(s''z'')) \rightarrow_\beta 
            \]
            \[
                \lambda z\lambda s.((\lambda z''\lambda s''.s''(s''(s''z''))) \; ((\lambda z'\lambda s'.s'(s'z')) \; z \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda z''\lambda s''.s''(s''(s''z'')) \; ((\lambda s'.s'(s'z))  \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda z''\lambda s''.s''(s''(s''z'')) \; (s(sz)) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.(\lambda s''.s''(s''(s''(s(sz)))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s.s(s(s(s(sz)))) = \overline{5}
            \]
        \end{exercise}

        \begin{exercise}
            Utiliza la definición de la función \textsf{sum} para evaluar la siguiente  $\lambda$-expresión
            \[
                \textsf{sum}\  \overline{4} \; \overline{5} 
            \]
            \[
                = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s) \; \lambda z'\lambda s'.s'(s'(s'(s'z'))) \; \lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \rightarrow_\beta 
            \]
            \[
                (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.s'(s'(s'(s'z'))) \; z \; s) \; s)) \; \lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \rightarrow_\beta 
            \]
            \[
                \lambda z\lambda s(\lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \; (\lambda z'\lambda s'.s'(s'(s'(s'z'))) \; z \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s((\lambda z''\lambda s''.s''(s''(s''(s''(s''z''))))) \; (\lambda s'.s'(s'(s'(s'z)))  \; s) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s(\lambda z''\lambda s''.s''(s''(s''(s''(s''z'')))) \; s(s(s(sz))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda z\lambda s(\lambda s''.s''(s''(s''(s''(s''(s(s(s(sz)))))))) \; s) \rightarrow_\beta
            \]
            \[
                \lambda s.\lambda z .s(s(s(s(s(s(s(s(sz)))))))) = \overline{9}
            \]
        \end{exercise}

        \subsubsection{Producto}
        Para el producto de $m$ y $n$ la idea es anidar la operación: n + n, m veces reemplazando las aparaciones de de la variable $s$ en el numeral m por sum(n ... , esta operación está definida de la siguiente manera:

        \begin{definition}[Definición del producto para los numerales de Church.]\footnote{Definición extraída de \hyperlink{109}{[109]} y  \hyperlink{111}{[111]}}
            $$\textsf{prod} =_{def}  \; \lambda m.\lambda n.m\; \bar{0} \; (\textsf{sum}\;n)$$
        \end{definition}

        \begin{exercise}
            Utiliza la definición de la función \textsf{prod} para evaluar la siguiente  $\lambda$-expresión
            \[
                    \textsf{prod}\  \overline{2} \; \overline{3}
            \]
            \[
                    (\lambda m\lambda n.m\; \overline{0} \; (\textsf{sum} \; n)) \;  \lambda z\lambda s.s(sz) \; \overline{3} \rightarrow_\beta 
            \]
            \[
			(\lambda n.(\lambda z\lambda s.s(sz)) \; \overline{0} \; (\textsf{sum} \; n)) \; \overline{3}   \rightarrow_\beta 
 	    \]
            \[
                       (\lambda n.(\lambda s.s(s\ \overline{0}))\; (\textsf{sum}\; n)) \; \overline{3} \rightarrow_\beta 
            \]
	    \[
			 (\lambda n.(\textsf{sum} \; n \; (\textsf{sum} \; n \; \overline{0})) \; \overline{3}  \rightarrow_\beta 
	    \]
            \[
                        (\textsf{sum} \; \overline{3} \; (\textsf{sum} \; \overline{3} \; \overline{0})) = 
            \]
            \[
                    \scalemath{0.8}{
                        \lambda m\lambda n\lambda s\lambda z.n(m \; z \; s) \; s \; \lambda z'\lambda s'.s'(s'(s'z')) \; (\lambda m'\lambda n'\lambda s''\lambda z''.n'(m' \; z'' \; s'') \; s'' \; \lambda z'''\lambda s'''.s'''(s'''(s'''z''')) \; \lambda z''''\lambda s''''.z'''') 
                    }
            \]
            \[
                    \text{resolveremos por partes la suma dado que la notación crece muy rápido y es poco legible}
            \]
            \[
                    \textsf{sum}\  \overline{3} \; \overline{0} = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s ) \; \lambda z'\lambda s'.z' \; \overline{3}
            \]
            \[
                    \rightarrow_\beta  (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s'.z') \; z \; s) \; s) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta  (\lambda n\lambda z\lambda s.n(\lambda s'.z \; s) \; s) \; \overline{3} 
            \]
	 \[
            	\rightarrow_\beta  (\lambda n\lambda z\lambda s.n \; z \; s) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta   \lambda z\lambda s.(\overline{3} \; z \; s \;) = \; \lambda z\lambda s.((\lambda z'\lambda s'.s'(s'(s'z'))) \; z \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.(\lambda s'.s'(s'(s'(z))) \; s) 
            \]
            \[
	         \rightarrow_\beta \lambda z\lambda s.s(s(sz)) = \overline{3} 
            \]
            \[
                    \textbf{sum } \; \overline{3} \; \overline{3} = (\lambda m\lambda n\lambda z\lambda s.n(m \; z \; s) \; s ) \; \lambda z'\lambda s's'(s'(s'.z')) \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n((\lambda z'\lambda s's'(s'(s'.z'))) \; z \; s) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n((\lambda s's'(s'(s'.z))) \; s) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta (\lambda n\lambda z\lambda s.n \; (s(s(s.z))) \; s )  \; \overline{3}
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.((\overline{3}) \; (s(s(s.z))) \; s) = \lambda m\lambda n\lambda z\lambda s.(( \lambda z'\lambda s'.s'(s'(s'z'))) \; (s(s(s.z))) \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.((\lambda s'.s'(s'(s'(s(s(s.z))))))  \; s)
            \]
            \[
                    \rightarrow_\beta \lambda z\lambda s.\lambda s.s(s(s(s(s(s.z))))) = \overline{6}
            \]
        \end{exercise}

        \section{Datos estructurados en el Cálculo Lambda}

            En el Cálculo Lambda es posible definir estructuras para almacenar información junto con las funciones para recuperar los elementos guardados en estas. La estructura más simple que revisaremos serán las tuplas junto con sus proyecciones \textsf{first} y \textsf{second} que ayudan a sentar la base para definir una estructura más compleja; las listas, con sus respectivas funciones para obtener la cabeza y la cola. Juntas proveen una estructura de datos para almacenamiento en este sistema.
    
            \subsection{Tuplas}

                La tupla es la estructura que representa a un par compuesto por un elemento izquierdo y un elemento derecho. En el Cálculo Lambda se define como la función que tiene tiene tres argumentos; el elemento izquierdo (en inglés se le conoce como $first$), el elemento derecho (o $second$) y una función $b$.
        
                \begin{definition}[Definición de tuplas para el Cálculo Lambda]\footnote{Definición extraída de \hyperlink{12}{[12]},  \hyperlink{110}{[110]} y   \hyperlink{13}{[13]}}
            
                    Constructor
                        $$\mathsf{pair} = \lambda f\lambda s\lambda b. bfs$$
                    Proyección del primer elemento
                        $$\mathsf{fst} = \lambda p.p \ \textsf{True}$$
                    Proyección del segundo elemento
                        $$\mathsf{snd} = \lambda p.p \ \textsf{False}$$

		      Donde las proyecciones se apoyan de la propiedad de los booleanos de regresar el primer argumento para el caso de \textsf{True} y el segundo en el caso de \textsf{False}.
                \end{definition}

                En general se tienen las siguiente reducciones cuando se aplican las proyecciones a las tuplas:

                $${\sf fst}\;({\sf pair}\;{\sf a} \; {\sf b}) \to_\beta ^* {\sf a}$$
                $${\sf snd}\;({\sf pair}\;{\sf a} \; {\sf b}) \to_\beta ^* {\sf b}$$ 

            \subsection{Listas}
            Las listas en el Cálculo Lambda se apoyan del constructor de la tupla para ir añadiendo elementos anidando esta operación agregando una unidad por aplicación. 
            Para esta estrcutura la lista vacía será representada por una $\lambda$-expresión que sea $\alpha$-equivalente a la constante \textsf{False}.

            \begin{definition}[Definición de listas en Cálculo Lambda]\footnote{Definición extraída de \hyperlink{12}{[12]},  \hyperlink{110}{[110]} y   \hyperlink{13}{[13]}}\\\\
                \text{Lista vacía}
                $${\sf nil}  = \textsf{False}$$
                \text{Constructor para listas}
                $${\sf cons} = \textsf{pair}$$
                \text{Cabeza de una lista}
                $${\sf head}  = \textsf{fst}$$
                \text{Cola de la lista}
                $${\sf tail} = \textsf{snd}$$
            \end{definition}

        \section{Propiedades semánitcas del Cálculo Lambda}

                \subsection{No terminación}
                    Estudiamos la propiedad de terminación para las expresiones correctamente formadas de \textsf{EAB}, en donde estas se evaluarán a un valor en un número finito de pasos (cuando la evaluación ha llegado a este punto se le conoce como forma normal). 
                    No obstante esta propiedad no se cumple para el Cálculo Lambda como se puede ver a continuación:
                    \begin{exercise}
                        Demuestra o da un contraejemplo de por qué la porpiedad de terminación para el Cálculo Lámnbda es válida.\\\\
                        Consideremos el siguiente par de $\lambda$-expresiones:\\
                        $$ \omega = \lambda x.xx$$
                        $$ \Omega = \omega \omega$$
                        $$ \Omega = \omega \omega = (\lambda x.xx) \omega \omega \rightarrow_\beta \omega \omega$$
                        En general esta expresión cumple que en cada $\beta$-reducción se tiene la misma expresión $\Omega$.
                        Por lo tanto una expresión bien formada del Cálculo Lambda no necesariamente tiene una forma normal.
                    \end{exercise}

                \subsection{No determinismo}
                    En los lenguajes de programación una propiedad deseable es la propiedad determinista de los programas, es decir, que la evaluación que se haga para una expresión sea siempre la misma. El Cálculo Lambda carece de esta propiedad. Dependiendo del segmento que escogamos para aplicar la $\beta$-reducción el siguiente paso de la evaluación puede diferir.\\
		   Tomemos como ejemplo la siguiente $\lambda$-expresión:
                    $$(\lambda z.(\lambda y.z)a)b$$
                    Si consideramos la aplicación para la expresión completa, se obtine la siguiente evaluación: $$\underline{(\lambda z.(\lambda y.z)a)b} \rightarrow_\beta (\lambda y.b)a$$
                    Si por el contrario consideramos la aplicación la $\lambda$-expresión interna se obtiene: $$(\lambda z.\underline{(\lambda y.z)a})b \rightarrow_\beta (\lambda z.z)b$$
                    En ambas evaluaciones el resultado al que se llega al terminar de evaluar la expresión es la variable b sin importar cuál se haya escogido para la evaluación.\\\\
                    Esta característica del Cálculo Lambda no supone una desventaja por el principio de confluencia.

                \subsection{Confluencia}
                    El principio de confluencia nos asegura que dadas dos dos evaluaciones distintas para la misma $\lambda$-expresión, estas convergen en un término común en un punto de su evaluación:

                    \begin{theorem}[Propiedad de Church-Rosser]\footnote{La demostración queda fuera del alcance de este manual pero se puede consultar en \hyperlink{114}{[114]}}\\\\
 Si $e\to_\beta^* e_1$ y $e\to_\beta^*e_2$ entonces existe un término $t$ tal que  $e_1\to_\beta^* t$ y $e_2\to_\beta^* t$.
                    \end{theorem}

                    \begin{corollary}[Unicidad de formas normales]
Para cualquier $\lambda$-expresión $e$ si $e\to_\beta^*e_f$ y $e\to_\beta^*e_f'$ tal que  $\neg \exists\ e_{final}\ y\ e_{final}'$ donde $e_f \rightarrow_{\beta} e_{final}\ \ y\ \ e_f' \rightarrow_{\beta}\ e_{final}'$
entonces $e_f = e_f'$ salvo $\alpha$-equivalencias. 
                    \end{corollary}

        \section{Combinadores de punto fijo}
                    El Cálculo Lambda por si mísmo no posee un mecanisno iterativo que nos permita formar alguna secuencia de control como los ciclos \textsf{for} o \textsf{while} como en la mayoría de los lenguajes de programación modernos. Su naturaleza funcional nos hace preguntarnos si podemos emplear un mecanismo mas afín como la recursión para definir funciones que iteren sobre algún parámetro.\\\\
                   Para este fin se precisa de la introducción de los combinadores de punto fijo que capturan la escencia del principio de recursión general en computación:
                    $$ rec\ F\ =\ F\ (rec\ F) $$
                    De esta forma, si definimos una $\lambda$-expresión rec que permita la ''autoaplicación'' de si misma a una función que tome como parámetro, entonces podemos definir cualquier función recursiva aplicando n veces el mismo procedimiento.
                    $$rec\ F = F(rec\ F) = F(\ F(rec\ F)) =\ ...\ F(\ F(\ F(\ ...\ )))$$
                    
                    \begin{definition}[Combinador de punto fijo] Un $\lambda$-expresión cerrada $F$ es un combinador de punto fijo sí y sólo si cumple alguna de las siguientes condiciones\footnote{Definición formulada de \hyperlink{5}{[5]}, \hyperlink{12}{[12]} y \hyperlink{113}{[113]}}:
                        \begin{enumerate}
                            \item $F\,g\to_\beta^*g\,(F\,g)$
                            \item $F\,g\equiv_\beta g\,(F\,g)$ es decir, existe un término $t$ tal que $F\,g\to_\beta^*t$ y $g\,(F\,g)\to_\beta^*t$
                        \end{enumerate}
                    \end{definition}

              
                    \begin{definition}[Combinador $Y$] Existen diferentes $\lambda$-expresiones que cumplen con la definición provista anteriormente. Uno de los combinadores más sencillos y populares es el Combinador $Y$ que se define de la siguiente forma\footnote{Definición extraída de \hyperlink{113}{[113]}}:
                        $$Y =_{def} \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$$
                    \end{definition}
    
                    \begin{exercise} Demuestra que el combinador  $Y$ es un combinador de punto fijo.
                        \[
                            \begin{array}{cl}
                            &Y\,g\\
                            &(\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))\,g\\
                            \to_\beta&(\lambda x.g(xx))(\lambda x.g(xx))\\
                            \to_\beta&g((\lambda x.g(xx))(\lambda x.g(xx)))\\
                            \end{array}
                        \]
                    
                        Tomando la segunda parte de la igualdad y desarrollando obtenemos
                    
                        \[
                            \begin{array}{cl}
                            &g\,(Y\,g)\\
                            &g\,((\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))\,g)\\
                            \to_\beta&g\,((\lambda x.g(xx))(\lambda x.g(xx)))
                            \end{array}
                        \]
                    
                        de esta forma podemos concluir que $\Y\,g\equiv_\beta g\,(Y\,g)$, entonces $Y$ es un combinador de punto fijo.
                    \end{exercise}

            \section{Ejercicios para el lector}

                \begin{exercise}
                    Supón que se requiere extender la definición 4.1 para booleanos y sus operadores en el Cálculo Lambda implementando los siguientes operadores:
                    \[\textsf{IF}\]
                    \[\textsf{OR}\]
		Proporciona la $\lambda$-expresión que implemente dichas instrucciones.
                \end{exercise}

		\bigskip


                \begin{exercise}
                    Verifica las propiedas de la semántica operacional para cada operador booleano según la definición 4.2:

                        $$\mathsf{if}\,\textsf{true}\,e_1\,e_2 \to_\beta^* e_1$$ 
                        $$\mathsf{if}\,\textsf{false}\,e_1\,e_2 \to_\beta^* e_2$$ 
                        $$\mathsf{not}\,\textsf{true}\to_\beta^* \textsf{false}$$
                        $$\mathsf{not}\,\textsf{false}\to_\beta^* \textsf{true}$$
                        $$\mathsf{and}\,\textsf{false}\,b\to_\beta^* \textsf{false}$$
                        $$\mathsf{and}\,\textsf{true}\,b\to_\beta^* b$$
                        $$\mathsf{or}\,\textsf{true}\,b\to_\beta^* \textsf{true}$$
                        $$\mathsf{or}\,\textsf{false}\,b\to_\beta^* b$$
                        
                \end{exercise}


                \begin{exercise}
                    Resuelve las siguientes operaciones de los númerales de Church (el abuso de notación para simplificar $\lambda$-expresiones está permitido con el fin de tener una representación más compacta cuando sea posible)
                    \[
                            \textsf{prod}\ (\textsf{sum}\ \overline{7}\ \overline{4})\ \overline{2}
                    \]
                    \[
                            \textsf{IsZero} (\textsf{prod}\ \overline{1}\ \overline{0})
                    \]
                    \[
                            \textsf{IsZero}( \textsf{sum}\ \overline{3}\ (\textsf{prod}\ \overline{5}\ \overline{4}))
                    \]
                \end{exercise}  


                \begin{exercise}
                    Siguiendo la definición 6.2 de listas en el Cálculo Lambda define la función \textsf{IsNil} que se comporta de la siguiente forma
                    \[ \textsf{IsNil}\ []\ =\ \textsf{true} \]
                    \[ \textsf{IsNil}\ (x:xs)\  =\ \textsf{false}\]
                \end{exercise}


                \begin{exercise}
                    Encuentra la forma normal de las siguientes $\lambda$-expresiones, si no es posible explica por qué.\\
                    \[
                        (\lambda y.yy)(\lambda z.zz)(\lambda \alpha . \lambda \beta . \alpha \beta \alpha)\ \textsf{false} \; \overline{0}
                    \]
                    \[
                        ((\lambda z. \lambda y. \lambda u.uzy)(\lambda x.x)(\lambda wv.wv) \; \overline{0} \; \overline{1}) \; \textsf{true} 
                    \]
                \end{exercise}


                \begin{exercise}
                    Para cada una de las siguientes $\lambda$-expresiones demuestra que son combinadores de punto fijo.
                    

                        \[\text{Turing $V\ =\ UU$ en donde $U\ =\ \lambda f.\lambda x.x(ffx)$}\]
                        \[\text{Estricto $Z\ =\ \lambda f.(\lambda x.f(\lambda v.xxv))(\lambda x.f(\lambda v.xxv))$ }\]
            
                    
                \end{exercise}



                \begin{exercise}
                    Utilizando cualquiera de los combinadores de punto fijo implemeta la función recursiva \textsf{factorial} para los numerales de Church en el Cálculo Lambda.
                    \[ \textsf{factorial}\ 1\ =\ 1 \]
                    \[ \textsf{factorial}\ n\ =\ n\ *\ \textsf{factorial}\ n-1\]
                    Adicionalmente muestra la ejecución para n = $\overline{3}$
                \end{exercise}



                \begin{exercise}
                    Utilizando algún combinador de punto fijo implemeta la función recursiva \textsf{fibonacci} para los numerales de Church en el cálculo Lambda.
                    \[ \textsf{fibonacci}\ 0\ =\ 0 \]
                    \[ \textsf{fibonacci}\ 1\ =\ 1 \]
                    \[ \textsf{fibonacci}\ n\ =\ \textsf{fibonacci}\ n-1\ +\ \textsf{fibonacci}\ n-2\]
                    Adicionalmente muestra la ejecución para n = $\overline{3}$
                \end{exercise}

\bigskip

                \begin{exercise}
                    Utilizando el combinador $Y$, define la función \textsf{concat} para la representación de listas en el Cálculo Lambda.
                    \[
                        \textsf{concat}\ []\ (y:ys)\ =\ (y:ys)
                    \]
                    \[
                        \textsf{concat}\ (x:xs)\ (y:ys)\ = x:\textsf{concat}(xs\ (y:ys))
                    \]
                \end{exercise}

\bigskip

                \begin{exercise}
                    Utilizando cualquier combinador de punto fijo resuelve lo siguiente:\\
                    
                    Define la función reversa para las listas del Cálculo Lambda. \\
                    \[
                        \textsf{rev}\ []\ =\ []
                    \]
                    \[
                        \textsf{rev}\ (x:xs)\ =\ \textsf{rev}\ xs\ \text{++}\ [x]
                    \]
                    Aplica la función para obtener la reversa de la lista: pair 1 (pair 2 (pair 3 False))
                \end{exercise}

\bigskip

                \begin{exercise}
                    Utilizando el combinador $Y$ contesta lo siguiente: \\
                    \begin{itemize}
                    	\item Da una definición de la función de exponenciación para los numerales de Church.
                    	\item Resuelve la función para \textsf{exp} $\overline{4} \; \overline{2}$.
		    \end{itemize}
                \end{exercise}

%https://blog.brunobonacci.com/2017/10/08/lambda-calculus-and-boolean-logic/
%https://stackoverflow.com/questions/52548280/implementing-fibonacci-sequence-using-pure-lambda-calculus-and-church-numerals-i
%https://drive.google.com/file/d/1MM6Lu417pwH_zKl0kITA0EzSfJL8grP9/view
%

                    
            